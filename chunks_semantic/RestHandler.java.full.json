{
  "name": "RestHandler",
  "type": "class_full",
  "content": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.rest;\n\nimport org.apache.logging.log4j.Level;\nimport org.elasticsearch.client.internal.node.NodeClient;\nimport org.elasticsearch.common.logging.DeprecationLogger;\nimport org.elasticsearch.core.Nullable;\nimport org.elasticsearch.core.RestApiVersion;\nimport org.elasticsearch.rest.RestRequest.Method;\nimport org.elasticsearch.xcontent.XContent;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * Handler for REST requests\n */\n@FunctionalInterface\npublic interface RestHandler {\n\n    /**\n     * Handles a rest request.\n     * @param request The request to handle\n     * @param channel The channel to write the request response to\n     * @param client A client to use to make internal requests on behalf of the original request\n     */\n    void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception;\n\n    default boolean canTripCircuitBreaker() {\n        return true;\n    }\n\n    default boolean supportsContentStream() {\n        return false;\n    }\n\n    /**\n     * Indicates if the RestHandler supports bulk content. A bulk request contains multiple objects\n     * delineated by {@link XContent#bulkSeparator()}. If a handler returns true this will affect\n     * the types of content that can be sent to this endpoint.\n     */\n    default boolean supportsBulkContent() {\n        return false;\n    }\n\n    /**\n     * Returns the concrete RestHandler for this RestHandler. That is, if this is a delegating RestHandler it returns the delegate.\n     * Otherwise it returns itself.\n     * @return The underlying RestHandler\n     */\n    default RestHandler getConcreteRestHandler() {\n        return this;\n    }\n\n    /**\n     * Returns the serverless Scope of this RestHandler. This is only meaningful when running in a servlerless environment. If a\n     * RestHandler has no ServerlessScope annotation, then this method returns null, meaning that this RestHandler is not visible at all in\n     * Serverless mode.\n     * @return The Scope for this handler, or null if there is no ServerlessScope annotation\n     */\n    default Scope getServerlessScope() {\n        ServerlessScope serverlessScope = getConcreteRestHandler().getClass().getAnnotation(ServerlessScope.class);\n        return serverlessScope == null ? null : serverlessScope.value();\n    }\n\n    /**\n     * The list of {@link Route}s that this RestHandler is responsible for handling.\n     */\n    default List<Route> routes() {\n        return Collections.emptyList();\n    }\n\n    /**\n     * The set of path and query parameters that could be present on this handler.\n     * This method is only required due to <a href=\"https://github.com/elastic/elasticsearch/issues/36785\">#36785</a>,\n     * which conflates query and path parameters inside the rest handler.\n     * This method should be overridden to add path parameters to {@link #supportedQueryParameters}\n     * if the handler has path parameters.\n     * This method will be removed when {@link #supportedQueryParameters()} and {@link BaseRestHandler#responseParams()} are combined.\n     */\n    default @Nullable Set<String> allSupportedParameters() {\n        return supportedQueryParameters();\n    }\n\n    /**\n     * The set of query parameters accepted by this rest handler,\n     * {@code null} if query parameters should not be checked nor validated.\n     * TODO - make this not nullable when all handlers have been updated\n     */\n    default @Nullable Set<String> supportedQueryParameters() {\n        return null;\n    }\n\n    /**\n     * The set of capabilities this rest handler supports.\n     */\n    default Set<String> supportedCapabilities() {\n        return Set.of();\n    }\n\n    /**\n     * Controls whether requests handled by this class are allowed to to access system indices by default.\n     * @return {@code true} if requests handled by this class should be allowed to access system indices.\n     */\n    default boolean allowSystemIndexAccessByDefault() {\n        return false;\n    }\n\n    default boolean mediaTypesValid(RestRequest request) {\n        return request.getXContentType() != null;\n    }\n\n    default String getName() {\n        return this.getClass().getSimpleName();\n    }\n\n    class Route {\n\n        private final Method method;\n        private final String path;\n        private final RestApiVersion restApiVersion;\n        @Nullable\n        private final String deprecationMessage;\n        private final Level deprecationLevel;\n        @Nullable\n        private final Route replacedRoute;\n\n        private Route(\n            Method method,\n            String path,\n            RestApiVersion restApiVersion,\n            String deprecationMessage,\n            Level deprecationLevel,\n            Route replacedRoute\n        ) {\n            this.method = Objects.requireNonNull(method);\n            this.path = Objects.requireNonNull(path);\n            // the last version in which this route was fully supported\n            this.restApiVersion = Objects.requireNonNull(restApiVersion);\n\n            // a route marked as deprecated to keep or remove will have a deprecation message and level (warn for keep, critical for remove)\n            this.deprecationMessage = deprecationMessage;\n            this.deprecationLevel = Objects.requireNonNull(deprecationLevel);\n\n            if (deprecationMessage == null && deprecationLevel != Level.OFF) {\n                throw new IllegalArgumentException(\"deprecationMessage must be set if deprecationLevel is not OFF\");\n            }\n\n            // a route that replaces another route will have a reference to the route that was replaced\n            this.replacedRoute = replacedRoute;\n        }\n\n        /**\n         * Constructs a Route that pairs an HTTP method with an associated path.\n         * <p>\n         * This is sufficient for most routes in Elasticsearch, like \"GET /\", \"PUT /_cluster/settings\", or \"POST my_index/_close\".\n         *\n         * @param method the method, e.g. GET\n         * @param path   the path, e.g. \"/\"\n         */\n        public Route(Method method, String path) {\n            this(method, path, RestApiVersion.current(), null, Level.OFF, null);\n        }\n\n        public static class RouteBuilder {\n\n            private final Method method;\n            private final String path;\n            private RestApiVersion restApiVersion;\n\n            private String deprecationMessage;\n            private Level deprecationLevel;\n\n            private Route replacedRoute;\n\n            private RouteBuilder(Method method, String path) {\n                this.method = Objects.requireNonNull(method);\n                this.path = Objects.requireNonNull(path);\n                this.restApiVersion = RestApiVersion.current();\n            }\n\n            /**\n             * Marks that the route being built has been deprecated (for some reason -- the deprecationMessage) for removal. Notes the last\n             * major version in which the path is fully supported without compatibility headers. If this path is being replaced by another\n             * then use {@link #replaces(Method, String, RestApiVersion)} instead.\n             * <p>\n             * For example:\n             * <pre> {@code\n             * Route.builder(GET, \"_upgrade\")\n             *  .deprecatedForRemoval(\"The _upgrade API is no longer useful and will be removed.\", RestApiVersion.V_7)\n             *  .build()}</pre>\n             *\n             * @param deprecationMessage the user-visible explanation of this deprecation\n             * @param lastFullySupportedVersion the last {@link RestApiVersion} (i.e. 7) for which this route is fully supported.\n             *                                  The next major version (i.e. 8) will require compatibility header(s). (;compatible-with=7)\n             *                                  The next major version (i.e. 9) will have no support whatsoever for this route.\n             * @return a reference to this object.\n             */\n            public RouteBuilder deprecatedForRemoval(String deprecationMessage, RestApiVersion lastFullySupportedVersion) {\n                assert this.replacedRoute == null;\n                this.restApiVersion = Objects.requireNonNull(lastFullySupportedVersion);\n                this.deprecationMessage = Objects.requireNonNull(deprecationMessage);\n                // if being deprecated for removal in the current version, then it's a warning, otherwise it's critical\n                this.deprecationLevel = lastFullySupportedVersion == RestApiVersion.current() ? Level.WARN : DeprecationLogger.CRITICAL;\n                return this;\n            }\n\n            /**\n             * Marks that the route being built replaces another route, and notes the last major version in which the path is fully\n             * supported without compatibility headers.\n             * <p>\n             * For example:\n             * <pre> {@code\n             * Route.builder(GET, \"/_security/user/\")\n             *   .replaces(GET, \"/_xpack/security/user/\", RestApiVersion.V_7).build()}</pre>\n             *\n             * @param replacedMethod the method being replaced\n             * @param replacedPath the path being replaced\n             * @param lastFullySupportedVersion the last {@link RestApiVersion} (i.e. 7) for which this route is fully supported.\n             *                                  The next major version (i.e. 8) will require compatibility header(s). (;compatible-with=7)\n             *                                  The next major version (i.e. 9) will have no support whatsoever for this route.\n             * @return a reference to this object.\n             */\n            public RouteBuilder replaces(Method replacedMethod, String replacedPath, RestApiVersion lastFullySupportedVersion) {\n                assert this.deprecationMessage == null;\n\n                // if being replaced in the current version, then it's a warning, otherwise it's critical\n                Level deprecationLevel = lastFullySupportedVersion == RestApiVersion.current() ? Level.WARN : DeprecationLogger.CRITICAL;\n\n                // e.g. [POST /_optimize] is deprecated! Use [POST /_forcemerge] instead.\n                final String replacedMessage = \"[\"\n                    + replacedMethod.name()\n                    + \" \"\n                    + replacedPath\n                    + \"] is deprecated! Use [\"\n                    + this.method.name()\n                    + \" \"\n                    + this.path\n                    + \"] instead.\";\n\n                this.replacedRoute = new Route(\n                    replacedMethod,\n                    replacedPath,\n                    lastFullySupportedVersion,\n                    replacedMessage,\n                    deprecationLevel,\n                    null\n                );\n                return this;\n            }\n\n            /**\n             * Marks that the route being built has been deprecated (for some reason -- the deprecationMessage), but will not be removed.\n             * <p>\n             * For example:\n             * <pre> {@code\n             * Route.builder(GET, \"_upgrade\")\n             *  .deprecateAndKeep(\"The _upgrade API is no longer useful but will not be removed.\")\n             *  .build()}</pre>\n             *\n             * @param deprecationMessage the user-visible explanation of this deprecation\n             * @return a reference to this object.\n             */\n            public RouteBuilder deprecateAndKeep(String deprecationMessage) {\n                assert this.replacedRoute == null;\n                this.restApiVersion = RestApiVersion.current();\n                this.deprecationMessage = Objects.requireNonNull(deprecationMessage);\n                this.deprecationLevel = Level.WARN;\n                return this;\n            }\n\n            public Route build() {\n                assert (deprecationMessage != null) == (deprecationLevel != null);  // both must be set or neither\n                return new Route(\n                    method,\n                    path,\n                    restApiVersion,\n                    deprecationMessage,\n                    deprecationLevel == null ? Level.OFF : deprecationLevel,\n                    replacedRoute\n                );\n            }\n        }\n\n        public static RouteBuilder builder(Method method, String path) {\n            return new RouteBuilder(method, path);\n        }\n\n        public String getPath() {\n            return path;\n        }\n\n        public Method getMethod() {\n            return method;\n        }\n\n        public RestApiVersion getRestApiVersion() {\n            return restApiVersion;\n        }\n\n        @Nullable\n        public String getDeprecationMessage() {\n            return deprecationMessage;\n        }\n\n        public Level getDeprecationLevel() {\n            return deprecationLevel;\n        }\n\n        public boolean isDeprecated() {\n            return deprecationMessage != null;\n        }\n\n        @Nullable\n        public Route getReplacedRoute() {\n            return replacedRoute;\n        }\n\n        public boolean hasReplacement() {\n            return replacedRoute != null;\n        }\n    }\n}\n",
  "file_path": "./codebase_small/server/src/main/java/org/elasticsearch/rest/RestHandler.java"
}