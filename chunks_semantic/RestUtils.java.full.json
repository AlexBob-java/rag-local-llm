{
  "name": "RestUtils",
  "type": "class_full",
  "content": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.rest;\n\nimport org.elasticsearch.action.support.local.TransportLocalClusterStateAction;\nimport org.elasticsearch.action.support.master.AcknowledgedRequest;\nimport org.elasticsearch.common.Strings;\nimport org.elasticsearch.common.logging.DeprecationCategory;\nimport org.elasticsearch.common.logging.DeprecationLogger;\nimport org.elasticsearch.core.Booleans;\nimport org.elasticsearch.core.Nullable;\nimport org.elasticsearch.core.RestApiVersion;\nimport org.elasticsearch.core.TimeValue;\nimport org.elasticsearch.core.UpdateForV10;\n\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.UnaryOperator;\nimport java.util.regex.Pattern;\n\nimport static org.elasticsearch.action.support.master.AcknowledgedRequest.DEFAULT_ACK_TIMEOUT;\nimport static org.elasticsearch.rest.RestRequest.INTERNAL_MARKER_REQUEST_PARAMETERS;\n\npublic class RestUtils {\n\n    /**\n     * Sets whether we decode a '+' in an url as a space or not.\n     */\n    private static final boolean DECODE_PLUS_AS_SPACE = Booleans.parseBoolean(System.getProperty(\"es.rest.url_plus_as_space\", \"false\"));\n\n    public static final UnaryOperator<String> REST_DECODER = RestUtils::decodeComponent;\n\n    public static void decodeQueryString(URI uri, Map<String, String> params) {\n        final var rawQuery = uri.getRawQuery();\n        if (Strings.hasLength(rawQuery)) {\n            decodeQueryString(rawQuery, 0, params);\n        }\n    }\n\n    public static void decodeQueryString(String s, int fromIndex, Map<String, String> params) {\n        if (fromIndex < 0) {\n            return;\n        }\n        if (fromIndex >= s.length()) {\n            return;\n        }\n\n        int queryStringLength = s.contains(\"#\") ? s.indexOf('#') : s.length();\n\n        String name = null;\n        int pos = fromIndex; // Beginning of the unprocessed region\n        int i;       // End of the unprocessed region\n        char c = 0;  // Current character\n        for (i = fromIndex; i < queryStringLength; i++) {\n            c = s.charAt(i);\n            if (c == '=' && name == null) {\n                if (pos != i) {\n                    name = decodeQueryStringParam(s.substring(pos, i));\n                }\n                pos = i + 1;\n            } else if (c == '&' || c == ';') {\n                if (name == null && pos != i) {\n                    // We haven't seen an `=' so far but moved forward.\n                    // Must be a param of the form '&a&' so add it with\n                    // an empty value.\n                    addParam(params, decodeQueryStringParam(s.substring(pos, i)), \"\");\n                } else if (name != null) {\n                    addParam(params, name, decodeQueryStringParam(s.substring(pos, i)));\n                    name = null;\n                }\n                pos = i + 1;\n            }\n        }\n\n        if (pos != i) {  // Are there characters we haven't dealt with?\n            if (name == null) {     // Yes and we haven't seen any `='.\n                addParam(params, decodeQueryStringParam(s.substring(pos, i)), \"\");\n            } else {                // Yes and this must be the last value.\n                addParam(params, name, decodeQueryStringParam(s.substring(pos, i)));\n            }\n        } else if (name != null) {  // Have we seen a name without value?\n            addParam(params, name, \"\");\n        }\n    }\n\n    private static String decodeQueryStringParam(final String s) {\n        return decodeComponent(s, StandardCharsets.UTF_8, true);\n    }\n\n    private static void addParam(Map<String, String> params, String name, String value) {\n        for (var reservedParameter : INTERNAL_MARKER_REQUEST_PARAMETERS) {\n            if (reservedParameter.equalsIgnoreCase(name)) {\n                throw new IllegalArgumentException(\"parameter [\" + name + \"] is reserved and may not be set\");\n            }\n        }\n        params.put(name, value);\n    }\n\n    /**\n     * Decodes a bit of an URL encoded by a browser.\n     * <p>\n     * This is equivalent to calling {@link #decodeComponent(String, Charset, boolean)}\n     * with the UTF-8 charset (recommended to comply with RFC 3986, Section 2).\n     *\n     * @param s The string to decode (can be empty).\n     * @return The decoded string, or {@code s} if there's nothing to decode.\n     *         If the string to decode is {@code null}, returns an empty string.\n     * @throws IllegalArgumentException if the string contains a malformed\n     *                                  escape sequence.\n     */\n    public static String decodeComponent(final String s) {\n        return decodeComponent(s, StandardCharsets.UTF_8, DECODE_PLUS_AS_SPACE);\n    }\n\n    /**\n     * Decodes a bit of an URL encoded by a browser.\n     * <p>\n     * The string is expected to be encoded as per RFC 3986, Section 2.\n     * This is the encoding used by JavaScript functions {@code encodeURI}\n     * and {@code encodeURIComponent}, but not {@code escape}.  For example\n     * in this encoding, &eacute; (in Unicode {@code U+00E9} or in UTF-8\n     * {@code 0xC3 0xA9}) is encoded as {@code %C3%A9} or {@code %c3%a9}.\n     * <p>\n     * This is essentially equivalent to calling\n     * <code>{@link java.net.URLDecoder URLDecoder}.{@link\n     * java.net.URLDecoder#decode(String, String)}</code>\n     * except that it's over 2x faster and generates less garbage for the GC.\n     * Actually this function doesn't allocate any memory if there's nothing\n     * to decode, the argument itself is returned.\n     *\n     * @param s           The string to decode (can be empty).\n     * @param charset     The charset to use to decode the string (should really\n     *                    be {@link StandardCharsets#UTF_8}.\n     * @param plusAsSpace Whether to decode a {@code '+'} to a single space {@code ' '}\n     * @return The decoded string, or {@code s} if there's nothing to decode.\n     *         If the string to decode is {@code null}, returns an empty string.\n     * @throws IllegalArgumentException if the string contains a malformed\n     *                                  escape sequence.\n     */\n    private static String decodeComponent(final String s, final Charset charset, boolean plusAsSpace) {\n        if (s == null) {\n            return \"\";\n        }\n        final int size = s.length();\n        if (decodingNeeded(s, size, plusAsSpace) == false) {\n            return s;\n        }\n        final byte[] buf = new byte[size];\n        int pos = decode(s, size, buf, plusAsSpace);\n        return new String(buf, 0, pos, charset);\n    }\n\n    private static boolean decodingNeeded(String s, int size, boolean plusAsSpace) {\n        if (Strings.isEmpty(s)) {\n            return false;\n        }\n        int num = Math.min(s.length(), size);\n        for (int i = 0; i < num; i++) {\n            final char c = s.charAt(i);\n            if (c == '%' || (plusAsSpace && c == '+')) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @SuppressWarnings(\"fallthrough\")\n    private static int decode(String s, int size, byte[] buf, boolean plusAsSpace) {\n        int pos = 0;  // position in `buf'.\n        for (int i = 0; i < size; i++) {\n            char c = s.charAt(i);\n            switch (c) {\n                case '+':\n                    buf[pos++] = (byte) (plusAsSpace ? ' ' : '+');  // \"+\" -> \" \"\n                    break;\n                case '%':\n                    if (i == size - 1) {\n                        throw new IllegalArgumentException(\"unterminated escape sequence at end of string: \" + s);\n                    }\n                    c = s.charAt(++i);\n                    if (c == '%') {\n                        buf[pos++] = '%';  // \"%%\" -> \"%\"\n                        break;\n                    } else if (i == size - 1) {\n                        throw new IllegalArgumentException(\"partial escape sequence at end of string: \" + s);\n                    }\n                    c = decodeHexNibble(c);\n                    final char c2 = decodeHexNibble(s.charAt(++i));\n                    if (c == Character.MAX_VALUE || c2 == Character.MAX_VALUE) {\n                        throw new IllegalArgumentException(\n                            \"invalid escape sequence `%\" + s.charAt(i - 1) + s.charAt(i) + \"' at index \" + (i - 2) + \" of: \" + s\n                        );\n                    }\n                    c = (char) (c * 16 + c2);\n                    // Fall through.\n                default:\n                    buf[pos++] = (byte) c;\n                    break;\n            }\n        }\n        return pos;\n    }\n\n    /**\n     * Helper to decode half of a hexadecimal number from a string.\n     *\n     * @param c The ASCII character of the hexadecimal number to decode.\n     *          Must be in the range {@code [0-9a-fA-F]}.\n     * @return The hexadecimal value represented in the ASCII character\n     *         given, or {@link Character#MAX_VALUE} if the character is invalid.\n     */\n    private static char decodeHexNibble(final char c) {\n        if ('0' <= c && c <= '9') {\n            return (char) (c - '0');\n        } else if ('a' <= c && c <= 'f') {\n            return (char) (c - 'a' + 10);\n        } else if ('A' <= c && c <= 'F') {\n            return (char) (c - 'A' + 10);\n        } else {\n            return Character.MAX_VALUE;\n        }\n    }\n\n    /**\n     * Determine if CORS setting is a regex\n     *\n     * @return a corresponding {@link Pattern} if so and o.w. null.\n     */\n    public static Pattern checkCorsSettingForRegex(String corsSetting) {\n        if (corsSetting == null) {\n            return null;\n        }\n        int len = corsSetting.length();\n        boolean isRegex = len > 2 && corsSetting.startsWith(\"/\") && corsSetting.endsWith(\"/\");\n\n        if (isRegex) {\n            return Pattern.compile(corsSetting.substring(1, corsSetting.length() - 1));\n        }\n\n        return null;\n    }\n\n    /**\n     * Return the CORS setting as an array of origins.\n     *\n     * @param corsSetting the CORS allow origin setting as configured by the user;\n     *                    should never pass null, but we check for it anyway.\n     * @return an array of origins if set, otherwise {@code null}.\n     */\n    public static String[] corsSettingAsArray(String corsSetting) {\n        if (Strings.isNullOrEmpty(corsSetting)) {\n            return new String[0];\n        }\n        return Arrays.stream(corsSetting.split(\",\")).map(String::trim).toArray(String[]::new);\n    }\n\n    /**\n     * Extract the trace id from the specified traceparent string.\n     * @see <a href=\"https://www.w3.org/TR/trace-context/#traceparent-header\">W3 traceparent spec</a>\n     *\n     * @param traceparent   The value from the {@code traceparent} HTTP header\n     * @return  The trace id from the traceparent string, or {@code Optional.empty()} if it is not present.\n     */\n    public static Optional<String> extractTraceId(String traceparent) {\n        return traceparent != null && traceparent.length() >= 55 ? Optional.of(traceparent.substring(3, 35)) : Optional.empty();\n    }\n\n    /**\n     * The name of the common {@code ?master_timeout} query parameter.\n     */\n    public static final String REST_MASTER_TIMEOUT_PARAM = \"master_timeout\";\n\n    /**\n     * The default value for the common {@code ?master_timeout} query parameter.\n     */\n    public static final TimeValue REST_MASTER_TIMEOUT_DEFAULT = TimeValue.timeValueSeconds(30);\n\n    /**\n     * The name of the common {@code ?timeout} query parameter.\n     */\n    public static final String REST_TIMEOUT_PARAM = \"timeout\";\n\n    /**\n     * The name of the common {@code ?include_source_on_error} query parameter.\n     * By default, the document source is included in the error response in case of parsing errors. This parameter allows to disable this.\n     */\n    public static final String INCLUDE_SOURCE_ON_ERROR_PARAMETER = \"include_source_on_error\";\n\n    /**\n     * Extract the {@code ?master_timeout} parameter from the request, imposing the common default of {@code 30s} in case the parameter is\n     * missing.\n     *\n     * @param restRequest The request from which to extract the {@code ?master_timeout} parameter\n     * @return the timeout from the request, with a default of {@link #REST_MASTER_TIMEOUT_DEFAULT} ({@code 30s}) if the request does not\n     *         specify the parameter\n     */\n    public static TimeValue getMasterNodeTimeout(RestRequest restRequest) {\n        assert restRequest != null;\n        return restRequest.paramAsTime(REST_MASTER_TIMEOUT_PARAM, REST_MASTER_TIMEOUT_DEFAULT);\n    }\n\n    /**\n     * Extract the {@code ?timeout} parameter from the request, imposing the common default of {@code 30s} in case the parameter is\n     * missing.\n     *\n     * @param restRequest The request from which to extract the {@code ?timeout} parameter\n     * @return the timeout from the request, with a default of {@link AcknowledgedRequest#DEFAULT_ACK_TIMEOUT} ({@code 30s}) if the request\n     *         does not specify the parameter\n     */\n    public static TimeValue getAckTimeout(RestRequest restRequest) {\n        assert restRequest != null;\n        return restRequest.paramAsTime(REST_TIMEOUT_PARAM, DEFAULT_ACK_TIMEOUT);\n    }\n\n    /**\n     * Extract the {@code ?timeout} parameter from the request, returning null in case the parameter is missing.\n     *\n     * @param restRequest The request from which to extract the {@code ?timeout} parameter\n     * @return the timeout from the request, with a default of {@code null} if the request does not specify the parameter\n     */\n    @Nullable\n    public static TimeValue getTimeout(RestRequest restRequest) {\n        assert restRequest != null;\n        return restRequest.paramAsTime(REST_TIMEOUT_PARAM, null);\n    }\n\n    /**\n     * Extract the {@code ?include_source_on_error} parameter from the request, returning {@code true} in case the parameter is missing.\n     *\n     * @param restRequest The request from which to extract the {@code ?include_source_on_error} parameter\n     * @return the value of the {@code ?include_source_on_error} parameter from the request, with a default of {@code true} if the request\n     */\n    public static boolean getIncludeSourceOnError(RestRequest restRequest) {\n        assert restRequest != null;\n        return restRequest.paramAsBoolean(INCLUDE_SOURCE_ON_ERROR_PARAMETER, true);\n    }\n\n    // Remove the BWC support for the deprecated ?local parameter.\n    // NOTE: ensure each usage of this method has been deprecated for long enough to remove it.\n    @UpdateForV10(owner = UpdateForV10.Owner.DISTRIBUTED_COORDINATION)\n    public static void consumeDeprecatedLocalParameter(RestRequest request) {\n        if (request.hasParam(\"local\") == false) {\n            return;\n        }\n        // Consume this param just for validation when in BWC mode.\n        final var local = request.paramAsBoolean(\"local\", false);\n        if (request.getRestApiVersion() != RestApiVersion.V_8) {\n            DeprecationLogger.getLogger(TransportLocalClusterStateAction.class)\n                .critical(\n                    DeprecationCategory.API,\n                    \"TransportLocalClusterStateAction-local-parameter\",\n                    \"the [?local] query parameter to this API has no effect, is now deprecated, and will be removed in a future version\"\n                );\n        }\n    }\n}\n",
  "file_path": "./codebase_small/server/src/main/java/org/elasticsearch/rest/RestUtils.java"
}