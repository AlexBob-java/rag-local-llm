{
  "name": "ChunkedRestResponseBodyPart",
  "type": "class_full",
  "content": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\npackage org.elasticsearch.rest;\n\nimport org.apache.lucene.util.BytesRef;\nimport org.elasticsearch.action.ActionListener;\nimport org.elasticsearch.client.internal.Client;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.io.stream.BytesStream;\nimport org.elasticsearch.common.io.stream.RecyclerBytesStreamOutput;\nimport org.elasticsearch.common.recycler.Recycler;\nimport org.elasticsearch.common.xcontent.ChunkedToXContent;\nimport org.elasticsearch.core.CheckedConsumer;\nimport org.elasticsearch.core.IOUtils;\nimport org.elasticsearch.core.Releasables;\nimport org.elasticsearch.core.Streams;\nimport org.elasticsearch.logging.LogManager;\nimport org.elasticsearch.logging.Logger;\nimport org.elasticsearch.tasks.CancellableTask;\nimport org.elasticsearch.tasks.Task;\nimport org.elasticsearch.xcontent.ToXContent;\nimport org.elasticsearch.xcontent.XContentBuilder;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Iterator;\n\n/**\n * <p>A body (or a part thereof) of an HTTP response that uses the {@code chunked} transfer-encoding. This allows Elasticsearch to avoid\n * materializing the full response into on-heap buffers up front, instead serializing only as much of the response as can be flushed to the\n * network right away.</p>\n *\n * <p>Each {@link ChunkedRestResponseBodyPart} represents a sequence of chunks that are ready for <i>immediate</i> transmission: if\n * {@link #isPartComplete} returns {@code false} then {@link #encodeChunk} can be called at any time and must synchronously return the next\n * chunk to be sent. Many HTTP responses will be a single part, but if an implementation's {@link #isLastPart} returns {@code false} at the\n * end of the part then the transmission is paused and {@link #getNextPart} is called to compute the next sequence of chunks\n * asynchronously.</p>\n */\npublic interface ChunkedRestResponseBodyPart {\n\n    Logger logger = LogManager.getLogger(ChunkedRestResponseBodyPart.class);\n\n    /**\n     * @return {@code true} if this body part contains no more chunks and the REST layer should check for a possible continuation by calling\n     * {@link #isLastPart}, or {@code false} if the REST layer should request another chunk from this body using {@link #encodeChunk}.\n     */\n    boolean isPartComplete();\n\n    /**\n     * @return {@code true} if this is the last chunked body part in the response, or {@code false} if the REST layer should request further\n     * chunked bodies by calling {@link #getNextPart}.\n     */\n    boolean isLastPart();\n\n    /**\n     * <p>Asynchronously retrieves the next part of the response body. Called if {@link #isLastPart} returns {@code false}.</p>\n     *\n     * <p>Note that this is called on a transport thread: implementations must take care to dispatch any nontrivial work elsewhere.</p>\n\n     * <p>Note that the {@link Task} corresponding to any invocation of {@link Client#execute} completes as soon as the client action\n     * returns its response, so it no longer exists when this method is called and cannot be used to receive cancellation notifications.\n     * Instead, if the HTTP channel is closed while sending a response then the REST layer will invoke {@link RestResponse#close}. If the\n     * HTTP channel is closed while the REST layer is waiting for a continuation then the {@link RestResponse} will not be closed until the\n     * continuation listener is completed. Implementations will typically explicitly create a {@link CancellableTask} to represent the\n     * computation and transmission of the entire {@link RestResponse}, and will cancel this task if the {@link RestResponse} is closed\n     * prematurely.</p>\n     *\n     * @param listener Listener to complete with the next part of the body. By the point this is called we have already started to send\n     *                 the body of the response, so there's no good ways to handle an exception here. Completing the listener exceptionally\n     *                 will log an error, abort sending the response, and close the HTTP connection.\n     */\n    void getNextPart(ActionListener<ChunkedRestResponseBodyPart> listener);\n\n    /**\n     * Serializes approximately as many bytes of the response as request by {@code sizeHint} to a {@link ReleasableBytesReference} that\n     * is created from buffers backed by the given {@code recycler}.\n     *\n     * @param sizeHint how many bytes to approximately serialize for the given chunk\n     * @param recycler recycler used to acquire buffers\n     * @return serialized chunk\n     * @throws IOException on serialization failure\n     */\n    ReleasableBytesReference encodeChunk(int sizeHint, Recycler<BytesRef> recycler) throws IOException;\n\n    /**\n     * @return the response Content-Type header value for this response body\n     */\n    String getResponseContentTypeString();\n\n    /**\n     * Create a one-part chunked response body to be written to a specific {@link RestChannel} from a {@link ChunkedToXContent}.\n     *\n     * @param chunkedToXContent chunked x-content instance to serialize\n     * @param params parameters to use for serialization\n     * @param channel channel the response will be written to\n     * @return chunked rest response body\n     */\n    static ChunkedRestResponseBodyPart fromXContent(ChunkedToXContent chunkedToXContent, ToXContent.Params params, RestChannel channel)\n        throws IOException {\n\n        return new ChunkedRestResponseBodyPart() {\n\n            private final OutputStream out = new OutputStream() {\n                @Override\n                public void write(int b) throws IOException {\n                    target.write(b);\n                }\n\n                @Override\n                public void write(byte[] b, int off, int len) throws IOException {\n                    target.write(b, off, len);\n                }\n            };\n\n            private final XContentBuilder builder = channel.newBuilder(\n                channel.request().getXContentType(),\n                null,\n                true,\n                Streams.noCloseStream(out)\n            );\n\n            private final Iterator<? extends ToXContent> serialization = chunkedToXContent.toXContentChunked(\n                builder.getRestApiVersion(),\n                params\n            );\n\n            private BytesStream target;\n\n            @Override\n            public boolean isPartComplete() {\n                return serialization.hasNext() == false;\n            }\n\n            @Override\n            public boolean isLastPart() {\n                return true;\n            }\n\n            @Override\n            public void getNextPart(ActionListener<ChunkedRestResponseBodyPart> listener) {\n                assert false : \"no continuations\";\n                listener.onFailure(new IllegalStateException(\"no continuations available\"));\n            }\n\n            @Override\n            public ReleasableBytesReference encodeChunk(int sizeHint, Recycler<BytesRef> recycler) throws IOException {\n                try {\n                    final RecyclerBytesStreamOutput chunkStream = new RecyclerBytesStreamOutput(recycler);\n                    assert target == null;\n                    target = chunkStream;\n                    while (serialization.hasNext()) {\n                        serialization.next().toXContent(builder, params);\n                        if (chunkStream.size() >= sizeHint) {\n                            break;\n                        }\n                    }\n                    if (serialization.hasNext() == false) {\n                        builder.close();\n                    }\n                    final var result = chunkStream.moveToBytesReference();\n                    target = null;\n                    return result;\n                } catch (Exception e) {\n                    logger.error(\"failure encoding chunk\", e);\n                    throw e;\n                } finally {\n                    if (target != null) {\n                        assert false : \"failure encoding chunk\";\n                        IOUtils.closeWhileHandlingException(target);\n                        target = null;\n                    }\n                }\n            }\n\n            @Override\n            public String getResponseContentTypeString() {\n                return builder.getResponseContentTypeString();\n            }\n        };\n    }\n\n    /**\n     * Create a one-part chunked response body to be written to a specific {@link RestChannel} from a stream of UTF-8-encoded text chunks,\n     * each represented as a consumer of a {@link Writer}.\n     */\n    static ChunkedRestResponseBodyPart fromTextChunks(String contentType, Iterator<CheckedConsumer<Writer, IOException>> chunkIterator) {\n        return new ChunkedRestResponseBodyPart() {\n            private RecyclerBytesStreamOutput currentOutput;\n            private final Writer writer = new OutputStreamWriter(new OutputStream() {\n                @Override\n                public void write(int b) throws IOException {\n                    assert currentOutput != null;\n                    currentOutput.write(b);\n                }\n\n                @Override\n                public void write(byte[] b, int off, int len) throws IOException {\n                    assert currentOutput != null;\n                    currentOutput.write(b, off, len);\n                }\n\n                @Override\n                public void flush() {\n                    assert currentOutput != null;\n                    currentOutput.flush();\n                }\n\n                @Override\n                public void close() {\n                    assert currentOutput != null;\n                    currentOutput.flush();\n                }\n            }, StandardCharsets.UTF_8);\n\n            @Override\n            public boolean isPartComplete() {\n                return chunkIterator.hasNext() == false;\n            }\n\n            @Override\n            public boolean isLastPart() {\n                return true;\n            }\n\n            @Override\n            public void getNextPart(ActionListener<ChunkedRestResponseBodyPart> listener) {\n                assert false : \"no continuations\";\n                listener.onFailure(new IllegalStateException(\"no continuations available\"));\n            }\n\n            @Override\n            public ReleasableBytesReference encodeChunk(int sizeHint, Recycler<BytesRef> recycler) throws IOException {\n                try {\n                    assert currentOutput == null;\n                    currentOutput = new RecyclerBytesStreamOutput(recycler);\n\n                    while (chunkIterator.hasNext() && currentOutput.size() < sizeHint) {\n                        chunkIterator.next().accept(writer);\n                    }\n\n                    if (chunkIterator.hasNext()) {\n                        writer.flush();\n                    } else {\n                        writer.close();\n                    }\n\n                    final var chunkOutput = currentOutput;\n                    final var result = new ReleasableBytesReference(\n                        chunkOutput.bytes(),\n                        () -> Releasables.closeExpectNoException(chunkOutput)\n                    );\n                    currentOutput = null;\n                    return result;\n                } catch (Exception e) {\n                    logger.error(\"failure encoding text chunk\", e);\n                    throw e;\n                } finally {\n                    if (currentOutput != null) {\n                        assert false : \"failure encoding text chunk\";\n                        Releasables.closeExpectNoException(currentOutput);\n                        currentOutput = null;\n                    }\n                }\n            }\n\n            @Override\n            public String getResponseContentTypeString() {\n                return contentType;\n            }\n        };\n    }\n}\n",
  "file_path": "./codebase_small/server/src/main/java/org/elasticsearch/rest/ChunkedRestResponseBodyPart.java"
}