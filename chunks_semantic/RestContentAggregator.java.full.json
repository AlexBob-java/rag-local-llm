{
  "name": "RestContentAggregator",
  "type": "class_full",
  "content": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.rest;\n\nimport org.elasticsearch.common.bytes.CompositeBytesReference;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.core.Releasables;\nimport org.elasticsearch.http.HttpBody;\n\nimport java.util.ArrayList;\nimport java.util.function.Consumer;\n\npublic class RestContentAggregator {\n\n    private static void replaceBody(RestRequest restRequest, ReleasableBytesReference aggregate) {\n        restRequest.getHttpRequest().setBody(new HttpBody.ByteRefHttpBody(aggregate));\n    }\n\n    /**\n     * Aggregates content of the RestRequest and notifies consumer with updated, in-place, RestRequest.\n     * If content is already aggregated then passes through same request.\n     */\n    public static void aggregate(RestRequest restRequest, Consumer<RestRequest> resultConsumer) {\n        final var httpRequest = restRequest.getHttpRequest();\n        switch (httpRequest.body()) {\n            case HttpBody.Full full -> resultConsumer.accept(restRequest);\n            case HttpBody.Stream stream -> {\n                final var aggregationHandler = new AggregationChunkHandler(restRequest, resultConsumer);\n                stream.setHandler(aggregationHandler);\n                stream.next();\n            }\n        }\n    }\n\n    private static class AggregationChunkHandler implements HttpBody.ChunkHandler {\n        final RestRequest restRequest;\n        final Consumer<RestRequest> resultConsumer;\n        final HttpBody.Stream stream;\n        boolean closing;\n        ArrayList<ReleasableBytesReference> chunks;\n\n        private AggregationChunkHandler(RestRequest restRequest, Consumer<RestRequest> resultConsumer) {\n            this.restRequest = restRequest;\n            this.resultConsumer = resultConsumer;\n            this.stream = restRequest.getHttpRequest().body().asStream();\n        }\n\n        @Override\n        public void onNext(ReleasableBytesReference chunk, boolean isLast) {\n            if (closing) {\n                chunk.close();\n                return;\n            }\n            if (isLast == false) {\n                if (chunks == null) {\n                    chunks = new ArrayList<>(); // allocate array only when there is more than one chunk\n                }\n                chunks.add(chunk);\n                stream.next();\n            } else {\n                if (chunks == null) {\n                    replaceBody(restRequest, chunk);\n                } else {\n                    chunks.add(chunk);\n                    var comp = CompositeBytesReference.of(chunks.toArray(new ReleasableBytesReference[0]));\n                    var relComp = new ReleasableBytesReference(comp, Releasables.wrap(chunks));\n                    replaceBody(restRequest, relComp);\n                }\n                chunks = null;\n                closing = true;\n                resultConsumer.accept(restRequest);\n            }\n        }\n\n        @Override\n        public void close() {\n            if (closing == false) {\n                closing = true;\n                if (chunks != null) {\n                    Releasables.close(chunks);\n                    chunks = null;\n                }\n            }\n        }\n    }\n\n}\n",
  "file_path": "./codebase_small/server/src/main/java/org/elasticsearch/rest/RestContentAggregator.java"
}