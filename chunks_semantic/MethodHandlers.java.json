[
  {
    "name": "MethodHandlers",
    "type": "class",
    "content": "public final class MethodHandlers {\n\n    private final String path;\n    private final Map<RestRequest.Method, Map<RestApiVersion, RestHandler>> methodHandlers;\n\n     @SuppressWarnings(\"unused\")\n    // only accessed via #STATS_TRACKER_HANDLE, lazy initialized because instances consume non-trivial heap\n    private HttpRouteStatsTracker statsTracker;\n\n    private static final VarHandle STATS_TRACKER_HANDLE;\n\n    static  {\n        try  {\n            STATS_TRACKER_HANDLE = MethodHandles.lookup().findVarHandle(MethodHandlers.class, \"statsTracker\", HttpRouteStatsTracker.class);\n         } catch (NoSuchFieldException | IllegalAccessException e)  {\n            throw new ExceptionInInitializerError(e);\n         }\n     }\n\n    MethodHandlers(String path) { ... }\n\n    public String getPath() { ... }\n\n     /**\n      * Add a handler for an additional array of methods. Note that MethodHandlers\n      * does not allow replacing the handler for an already existing method.\n      */\n    MethodHandlers addMethod(RestRequest.Method method, RestApiVersion version, RestHandler handler) { ... }\n\n     /**\n      * Returns the handler for the given method and version.\n      *\n      * If a handler for given version do not exist, a handler for RestApiVersion.current() will be returned. The reasoning behind is that in a minor a new API could be added passively, therefore new APIs are compatible (as opposed to non-compatible/breaking) or null if none exists.\n      */\n    RestHandler getHandler(RestRequest.Method method, RestApiVersion version) { ... }\n\n     /**\n      * Return a set of all valid HTTP methods for the particular path\n      */\n    Set<RestRequest.Method> getValidMethods() { ... }\n\n    public HttpRouteStats getStats() { ... }\n\n    public HttpRouteStatsTracker statsTracker() { ... }\n\n    private HttpRouteStatsTracker existingStatsTracker() { ... }\n}",
    "file_path": ""
  }
]