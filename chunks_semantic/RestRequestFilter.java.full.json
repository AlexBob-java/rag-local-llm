{
  "name": "RestRequestFilter",
  "type": "class_full",
  "content": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.rest;\n\nimport org.elasticsearch.ElasticsearchException;\nimport org.elasticsearch.common.Strings;\nimport org.elasticsearch.common.bytes.BytesReference;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.xcontent.XContentHelper;\nimport org.elasticsearch.common.xcontent.support.XContentMapValues;\nimport org.elasticsearch.core.Tuple;\nimport org.elasticsearch.xcontent.XContentBuilder;\nimport org.elasticsearch.xcontent.XContentType;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Identifies an object that supplies a filter for the content of a {@link RestRequest}. This interface should be implemented by a\n * {@link org.elasticsearch.rest.RestHandler} that expects there will be sensitive content in the body of the request such as a password\n */\npublic interface RestRequestFilter {\n\n    /**\n     * Wraps the RestRequest and returns a version that provides the filtered content\n     */\n    default RestRequest getFilteredRequest(RestRequest restRequest) {\n        Set<String> fields = getFilteredFields();\n        if (restRequest.hasContent() && fields.isEmpty() == false) {\n            return new RestRequest(restRequest) {\n\n                private BytesReference filteredBytes = null;\n\n                @Override\n                public boolean hasContent() {\n                    return true;\n                }\n\n                @Override\n                public ReleasableBytesReference content() {\n                    if (filteredBytes == null) {\n                        Tuple<XContentType, Map<String, Object>> result = XContentHelper.convertToMap(\n                            restRequest.requiredContent(),\n                            true,\n                            restRequest.getXContentType()\n                        );\n                        Map<String, Object> transformedSource = XContentMapValues.filter(\n                            result.v2(),\n                            null,\n                            fields.toArray(Strings.EMPTY_ARRAY)\n                        );\n                        try {\n                            XContentBuilder xContentBuilder = XContentBuilder.builder(result.v1().xContent()).map(transformedSource);\n                            filteredBytes = BytesReference.bytes(xContentBuilder);\n                        } catch (IOException e) {\n                            throw new ElasticsearchException(\"failed to parse request\", e);\n                        }\n                    }\n                    return ReleasableBytesReference.wrap(filteredBytes);\n                }\n            };\n        } else {\n            return restRequest;\n        }\n    }\n\n    /**\n     * The list of fields that should be filtered. This can be a dot separated pattern to match sub objects and also supports wildcards\n     */\n    Set<String> getFilteredFields();\n}\n",
  "file_path": "./codebase_small/server/src/main/java/org/elasticsearch/rest/RestRequestFilter.java"
}