[
  {
    "name": "RestController",
    "type": "plain_text",
    "content": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.rest;\n\nimport org.apache.logging.log4j.Level;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.lucene.util.BytesRef;\nimport org.elasticsearch.ElasticsearchException;\nimport org.elasticsearch.ElasticsearchStatusException;\nimport org.elasticsearch.action.ActionListener;\nimport org.elasticsearch.client.internal.node.NodeClient;\nimport org.elasticsearch.common.Strings;\nimport org.elasticsearch.common.breaker.CircuitBreaker;\nimport org.elasticsearch.common.bytes.BytesArray;\nimport org.elasticsearch.common.bytes.BytesReference;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.io.stream.BytesStream;\nimport org.elasticsearch.common.logging.DeprecationLogger;\nimport org.elasticsearch.common.path.PathTrie;\nimport org.elasticsearch.common.recycler.Recycler;\nimport org.elasticsearch.common.util.Maps;\nimport org.elasticsearch.common.util.concurrent.ThreadContext;\nimport org.elasticsearch.core.Nullable;\nimport org.elasticsearch.core.Releasable;\nimport org.elasticsearch.core.Releasables;\nimport org.elasticsearch.core.RestApiVersion;\nimport org.elasticsearch.core.Streams;\nimport org.elasticsearch.core.TimeValue;\nimport org.elasticsearch.core.UpdateForV10;\nimport org.elasticsearch.http.HttpHeadersValidationException;\nimport org.elasticsearch.http.HttpRouteStats;\nimport org.elasticsearch.http.HttpRouteStatsTracker;\nimport org.elasticsearch.http.HttpServerTransport;\nimport org.elasticsearch.indices.breaker.CircuitBreakerService;\nimport org.elasticsearch.rest.RestHandler.Route;\nimport org.elasticsearch.tasks.Task;\nimport org.elasticsearch.telemetry.TelemetryProvider;\nimport org.elasticsearch.telemetry.metric.LongCounter;\nimport org.elasticsearch.telemetry.tracing.Tracer;\nimport org.elasticsearch.transport.Transports;\nimport org.elasticsearch.usage.SearchUsageHolder;\nimport org.elasticsearch.usage.UsageService;\nimport org.elasticsearch.xcontent.XContentBuilder;\nimport org.elasticsearch.xcontent.XContentType;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Supplier;\n\nimport static org.elasticsearch.indices.SystemIndices.EXTERNAL_SYSTEM_INDEX_ACCESS_CONTROL_HEADER_KEY;\nimport static org.elasticsearch.indices.SystemIndices.SYSTEM_INDEX_ACCESS_CONTROL_HEADER_KEY;\nimport static org.elasticsearch.rest.RestResponse.TEXT_CONTENT_TYPE;\nimport static org.elasticsearch.rest.RestStatus.BAD_REQUEST;\nimport static org.elasticsearch.rest.RestStatus.INTERNAL_SERVER_ERROR;\nimport static org.elasticsearch.rest.RestStatus.METHOD_NOT_ALLOWED;\nimport static org.elasticsearch.rest.RestStatus.NOT_ACCEPTABLE;\nimport static org.elasticsearch.rest.RestStatus.OK;\n\npublic class RestController implements HttpServerTransport.Dispatcher {\n\n    private static final Logger logger = LogManager.getLogger(RestController.class);\n    private static final DeprecationLogger deprecationLogger = DeprecationLogger.getLogger(RestController.class);\n    /**\n     * list of browser safelisted media types - not allowed on Content-Type header\n     * https://fetch.spec.whatwg.org/#cors-safelisted-request-header\n     */\n    static final Set<String> SAFELISTED_MEDIA_TYPES = Set.of(\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\");\n\n    static final String ELASTIC_PRODUCT_HTTP_HEADER = \"X-elastic-product\";\n    static final String ELASTIC_PRODUCT_HTTP_HEADER_VALUE = \"Elasticsearch\";\n    static final Set<String> RESERVED_PATHS = Set.of(\"/__elb_health__\", \"/__elb_health__/zk\", \"/_health\", \"/_health/zk\");\n    private static final BytesReference FAVICON_RESPONSE;\n    public static final String STATUS_CODE_KEY = \"es_rest_status_code\";\n    public static final String HANDLER_NAME_KEY = \"es_rest_handler_name\";\n    public static final String REQUEST_METHOD_KEY = \"es_rest_request_method\";\n    public static final boolean ERROR_TRACE_DEFAULT = false;\n\n    static {\n        try (InputStream stream = RestController.class.getResourceAsStream(\"/config/favicon.ico\")) {\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            Streams.copy(stream, out);\n            FAVICON_RESPONSE = new BytesArray(out.toByteArray());\n        } catch (IOException e) {\n            throw new AssertionError(e);\n        }\n    }\n\n    private final PathTrie<MethodHandlers> handlers = new PathTrie<>(RestUtils.REST_DECODER);\n\n    private final RestInterceptor interceptor;\n\n    private final NodeClient client;\n\n    private final CircuitBreakerService circuitBreakerService;\n\n    private final UsageService usageService;\n    private final Tracer tracer;\n    private final LongCounter requestsCounter;\n    // If true, the ServerlessScope annotations will be enforced\n    private final ServerlessApiProtections apiProtections;\n\n    public static final String METRIC_REQUESTS_TOTAL = \"es.rest.requests.total\";\n\n    public RestController(\n        RestInterceptor restInterceptor,\n        NodeClient client,\n        CircuitBreakerService circuitBreakerService,\n        UsageService usageService,\n        TelemetryProvider telemetryProvider\n    ) {\n        this.usageService = usageService;\n        this.tracer = telemetryProvider.getTracer();\n        this.requestsCounter = telemetryProvider.getMeterRegistry()\n            .registerLongCounter(METRIC_REQUESTS_TOTAL, \"The total number of rest requests/responses processed\", \"unit\");\n        if (restInterceptor == null) {\n            restInterceptor = (request, channel, targetHandler, listener) -> listener.onResponse(Boolean.TRUE);\n        }\n        this.interceptor = restInterceptor;\n        this.client = client;\n        this.circuitBreakerService = circuitBreakerService;\n        registerHandlerNoWrap(RestRequest.Method.GET, \"/favicon.ico\", RestApiVersion.current(), new RestFavIconHandler());\n        this.apiProtections = new ServerlessApiProtections(false);\n    }\n\n    public ServerlessApiProtections getApiProtections() {\n        return apiProtections;\n    }\n\n    /**\n     * Registers a REST handler to be executed when the provided {@code method} and {@code path} match the request.\n     *\n     * @param method GET, POST, etc.\n     * @param path Path to handle (e.g. \"/{index}/{type}/_bulk\")\n     * @param version API version to handle (e.g. RestApiVersion.V_8)\n     * @param handler The handler to actually execute\n     * @param deprecationMessage The message to log and send as a header in the response\n     * @param deprecationLevel The deprecation log level to use for the deprecation warning, either WARN or CRITICAL\n     */\n    protected void registerAsDeprecatedHandler(\n        RestRequest.Method method,\n        String path,\n        RestApiVersion version,\n        RestHandler handler,\n        String deprecationMessage,\n        Level deprecationLevel\n    ) {\n        assert (handler instanceof DeprecationRestHandler) == false;\n        if (RestApiVersion.onOrAfter(RestApiVersion.minimumSupported()).test(version)) {\n            registerHandler(\n                method,\n                path,\n                version,\n                new DeprecationRestHandler(\n                    handler,\n                    method,\n                    path,\n                    deprecationLevel,\n                    deprecationMessage,\n                    deprecationLogger,\n                    version != RestApiVersion.current()\n                )\n            );\n        }\n    }\n\n    /**\n     * Registers a REST handler to be executed when the provided {@code method} and {@code path} match the request, or when provided\n     * with {@code replacedMethod} and {@code replacedPath}. Expected usage:\n     * <pre><code>\n     * // remove deprecation in next major release\n     * controller.registerAsDeprecatedHandler(POST, \"/_forcemerge\", RestApiVersion.V_8, someHandler,\n     *                                        POST, \"/_optimize\", RestApiVersion.V_7);\n     * controller.registerAsDeprecatedHandler(POST, \"/{index}/_forcemerge\", RestApiVersion.V_8, someHandler,\n     *                                        POST, \"/{index}/_optimize\", RestApiVersion.V_7);\n     * </code></pre>\n     * <p>\n     * The registered REST handler ({@code method} with {@code path}) is a normal REST handler that is not deprecated and it is\n     * replacing the deprecated REST handler ({@code replacedMethod} with {@code replacedPath}) that is using the <em>same</em>\n     * {@code handler}.\n     * <p>\n     * Deprecated REST handlers without a direct replacement should be deprecated directly using {@link #registerAsDeprecatedHandler}\n     * and a specific message.\n     *\n     * @param method GET, POST, etc.\n     * @param path Path to handle (e.g. \"/_forcemerge\")\n     * @param version API version to handle (e.g. RestApiVersion.V_8)\n     * @param handler The handler to actually execute\n     * @param replacedMethod GET, POST, etc.\n     * @param replacedPath <em>Replaced</em> path to handle (e.g. \"/_optimize\")\n     * @param replacedVersion <em>Replaced</em> API version to handle (e.g. RestApiVersion.V_7)\n     */\n    protected void registerAsReplacedHandler(\n        RestRequest.Method method,\n        String path,\n        RestApiVersion version,\n        RestHandler handler,\n        RestRequest.Method replacedMethod,\n        String replacedPath,\n        RestApiVersion replacedVersion,\n        String replacedMessage,\n        Level deprecationLevel\n    ) {\n        registerHandler(method, path, version, handler);\n        registerAsDeprecatedHandler(replacedMethod, replacedPath, replacedVersion, handler, replacedMessage, deprecationLevel);\n    }\n\n    /**\n     * Registers a REST handler to be executed when one of the provided methods and path match the request.\n     *\n     * @param method GET, POST, etc.\n     * @param path Path to handle (e.g. \"/{index}/{type}/_bulk\")\n     * @param version API version to handle (e.g. RestApiVersion.V_8)\n     * @param handler The handler to actually execute\n     */\n    protected void registerHandler(RestRequest.Method method, String path, RestApiVersion version, RestHandler handler) {\n        if (handler instanceof BaseRestHandler) {\n            usageService.addRestHandler((BaseRestHandler) handler);\n        }\n        registerHandlerNoWrap(method, path, version, handler);\n    }\n\n    private void registerHandlerNoWrap(RestRequest.Method method, String path, RestApiVersion version, RestHandler handler) {\n        assert RestApiVersion.minimumSupported() == version || RestApiVersion.current() == version\n            : \"REST API compatibility is only supported for version \"\n                + RestApiVersion.minimumSupported().major\n                + \" [method=\"\n                + method\n                + \", path=\"\n                + path\n                + \", handler=\"\n                + handler.getClass().getCanonicalName()\n                + \"]\";\n\n        if (RESERVED_PATHS.contains(path)) {\n            throw new IllegalArgumentException(\"path [\" + path + \"] is a reserved path and may not be registered\");\n        }\n        // the HTTP OPTIONS method is treated internally, not by handlers, see {@code #handleNoHandlerFound}\n        assert method != RestRequest.Method.OPTIONS : \"There should be no handlers registered for the OPTIONS HTTP method\";\n        handlers.insertOrUpdate(\n            path,\n            new MethodHandlers(path).addMethod(method, version, handler),\n            (handlers, ignoredHandler) -> handlers.addMethod(method, version, handler)\n        );\n    }\n\n    public void registerHandler(final Route route, final RestHandler handler) {\n        if (route.hasReplacement()) {\n            Route replaced = route.getReplacedRoute();\n            registerAsReplacedHandler(\n                route.getMethod(),\n                route.getPath(),\n                route.getRestApiVersion(),\n                handler,\n                replaced.getMethod(),\n                replaced.getPath(),\n                replaced.getRestApiVersion(),\n                replaced.getDeprecationMessage(),\n                replaced.getDeprecationLevel()\n            );\n        } else if (route.isDeprecated()) {\n            registerAsDeprecatedHandler(\n                route.getMethod(),\n                route.getPath(),\n                route.getRestApiVersion(),\n                handler,\n                route.getDeprecationMessage(),\n                route.getDeprecationLevel()\n            );\n        } else {\n            // it's just a normal route\n            registerHandler(route.getMethod(), route.getPath(), route.getRestApiVersion(), handler);\n        }\n    }\n\n    /**\n     * Registers a REST handler with the controller. The REST handler declares the {@code method}\n     * and {@code path} combinations.\n     */\n    public void registerHandler(final RestHandler handler) {\n        handler.routes().forEach(route -> registerHandler(route, handler));\n    }\n\n    @Override\n    public void dispatchRequest(RestRequest request, RestChannel channel, ThreadContext threadContext) {\n        threadContext.addResponseHeader(ELASTIC_PRODUCT_HTTP_HEADER, ELASTIC_PRODUCT_HTTP_HEADER_VALUE);\n        try {\n            tryAllHandlers(request, channel, threadContext);\n        } catch (Exception e) {\n            try {\n                sendFailure(channel, e);\n            } catch (Exception inner) {\n                inner.addSuppressed(e);\n                logger.error(() -> \"failed to send failure response for uri [\" + request.uri() + \"]\", inner);\n            }\n        }\n    }\n\n    @Override\n    public void dispatchBadRequest(final RestChannel channel, final ThreadContext threadContext, final Throwable cause) {\n        threadContext.addResponseHeader(ELASTIC_PRODUCT_HTTP_HEADER, ELASTIC_PRODUCT_HTTP_HEADER_VALUE);\n        try {\n            final Exception e;\n            if (cause == null) {\n                e = new ElasticsearchException(\"unknown cause\");\n            } else if (cause instanceof Exception) {\n                e = (Exception) cause;\n            } else {\n                e = new ElasticsearchException(cause);\n            }\n            // unless it's a http headers validation error, we consider any exceptions encountered so far during request processing\n            // to be a problem of invalid/malformed request (hence the RestStatus#BAD_REQEST (400) HTTP response code)\n            if (e instanceof HttpHeadersValidationException) {\n                sendFailure(channel, (Exception) e.getCause());\n            } else {\n                channel.sendResponse(new RestResponse(channel, BAD_REQUEST, e));\n                recordRequestMetric(BAD_REQUEST, requestsCounter);\n            }\n        } catch (final IOException e) {\n            if (cause != null) {\n                e.addSuppressed(cause);\n            }\n            logger.warn(\"failed to send bad request response\", e);\n            channel.sendResponse(new RestResponse(INTERNAL_SERVER_ERROR, RestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY));\n            recordRequestMetric(INTERNAL_SERVER_ERROR, requestsCounter);\n        }\n    }\n\n    public boolean checkSupported(\n        RestRequest.Method method,\n        String path,\n        Set<String> parameters,\n        Set<String> capabilities,\n        RestApiVersion restApiVersion\n    ) {\n        Iterator<MethodHandlers> allHandlers = getAllHandlers(null, path);\n        while (allHandlers.hasNext()) {\n            RestHandler handler;\n            MethodHandlers handlers = allHandlers.next();\n            if (handlers == null) {\n                handler = null;\n            } else {\n                handler = handlers.getHandler(method, restApiVersion);\n            }\n\n            if (handler != null) {\n                var supportedParams = handler.supportedQueryParameters();\n                assert supportedParams == handler.supportedQueryParameters()\n                    : handler.getName() + \": did not return same instance from supportedQueryParameters()\";\n                return (supportedParams == null || supportedParams.containsAll(parameters))\n                    && handler.supportedCapabilities().containsAll(capabilities);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public Map<String, HttpRouteStats> getStats() {\n        final Iterator<MethodHandlers> methodHandlersIterator = handlers.allNodeValues();\n        final SortedMap<String, HttpRouteStats> allStats = new TreeMap<>();\n        while (methodHandlersIterator.hasNext()) {\n            final MethodHandlers mh = methodHandlersIterator.next();\n            final HttpRouteStats stats = mh.getStats();\n            if (stats.requestCount() > 0 || stats.responseCount() > 0) {\n                allStats.put(mh.getPath(), stats);\n            }\n        }\n        return Collections.unmodifiableSortedMap(allStats);\n    }\n\n    private void maybeAggregateAndDispatchRequest(\n        RestRequest restRequest,\n        RestChannel restChannel,\n        RestHandler handler,\n        MethodHandlers methodHandlers,\n        ThreadContext threadContext\n    ) throws Exception {\n        if (handler.supportsContentStream()) {\n            dispatchRequest(restRequest, restChannel, handler, methodHandlers, threadContext);\n        } else {\n            RestContentAggregator.aggregate(restRequest, (aggregatedRequest) -> {\n                try {\n                    dispatchRequest(aggregatedRequest, restChannel, handler, methodHandlers, threadContext);\n                } catch (Exception e) {\n                    throw new ElasticsearchException(e);\n                }\n            });\n        }\n    }\n\n    private void dispatchRequest(\n        RestRequest request,\n        RestChannel channel,\n        RestHandler handler,\n        MethodHandlers methodHandlers,\n        ThreadContext threadContext\n    ) throws Exception {\n        if (request.hasContent()) {\n            if (isContentTypeDisallowed(request) || handler.mediaTypesValid(request) == false) {\n                sendContentTypeErrorMessage(request.getAllHeaderValues(\"Content-Type\"), channel);\n                return;\n            }\n            final XContentType xContentType = request.getXContentType();\n            // TODO consider refactoring to handler.supportsContentStream(xContentType). It is only used with JSON and SMILE\n            if (handler.supportsBulkContent()\n                && XContentType.JSON != xContentType.canonical()\n                && XContentType.SMILE != xContentType.canonical()) {\n                channel.sendResponse(\n                    RestResponse.createSimpleErrorResponse(\n                        channel,\n                        RestStatus.NOT_ACCEPTABLE,\n                        \"Content-Type [\" + xContentType + \"] does not support stream parsing. Use JSON or SMILE instead\"\n                    )\n                );\n                return;\n            }\n        }\n        RestChannel responseChannel = channel;\n        if (apiProtections.isEnabled()) {\n            Scope scope = handler.getServerlessScope();\n            if (scope == null) {\n                handleServerlessRequestToProtectedResource(request.uri(), request.method(), responseChannel);\n                return;\n            }\n        }\n        final int contentLength = request.isFullContent() ? request.contentLength() : 0;\n        try {\n            if (handler.canTripCircuitBreaker()) {\n                inFlightRequestsBreaker(circuitBreakerService).addEstimateBytesAndMaybeBreak(contentLength, \"<http_request>\");\n            } else {\n                inFlightRequestsBreaker(circuitBreakerService).addWithoutBreaking(contentLength);\n            }\n            // iff we could reserve bytes for the request we need to send the response also over this channel\n            responseChannel = new ResourceHandlingHttpChannel(channel, circuitBreakerService, contentLength, methodHandlers);\n\n            if (handler.allowSystemIndexAccessByDefault() == false) {\n                // The ELASTIC_PRODUCT_ORIGIN_HTTP_HEADER indicates that the request is coming from an Elastic product and\n                // therefore we should allow a subset of external system index access.\n                // This header is intended for internal use only.\n                final String prodOriginValue = request.header(Task.X_ELASTIC_PRODUCT_ORIGIN_HTTP_HEADER);\n                if (prodOriginValue != null) {\n                    threadContext.putHeader(SYSTEM_INDEX_ACCESS_CONTROL_HEADER_KEY, Boolean.TRUE.toString());\n                    threadContext.putHeader(EXTERNAL_SYSTEM_INDEX_ACCESS_CONTROL_HEADER_KEY, prodOriginValue);\n                } else {\n                    threadContext.putHeader(SYSTEM_INDEX_ACCESS_CONTROL_HEADER_KEY, Boolean.FALSE.toString());\n                }\n            } else {\n                threadContext.putHeader(SYSTEM_INDEX_ACCESS_CONTROL_HEADER_KEY, Boolean.TRUE.toString());\n            }\n\n            if (apiProtections.isEnabled()) {\n                // API protections are only enabled in serverless; therefore we can use this as an indicator to mark the\n                // request as a serverless mode request here, so downstream handlers can use the marker\n                request.markAsServerlessRequest();\n                logger.trace(\"Marked request for uri [{}] as serverless request\", request.uri());\n            }\n\n            final var finalChannel = responseChannel;\n            this.interceptor.intercept(request, responseChannel, handler.getConcreteRestHandler(), new ActionListener<>() {\n                @Override\n                public void onResponse(Boolean processRequest) {\n                    if (processRequest) {\n                        try {\n                            validateRequest(request, handler, client);\n                            handler.handleRequest(request, finalChannel, client);\n                        } catch (Exception e) {\n                            onFailure(e);\n                        }\n                    }\n                }\n\n                @Override\n                public void onFailure(Exception e) {\n                    try {\n                        sendFailure(finalChannel, e);\n                    } catch (IOException ex) {\n                        logger.info(\"Failed to send error [{}] to HTTP client\", ex.toString());\n                    }\n                }\n            });\n        } catch (Exception e) {\n            sendFailure(responseChannel, e);\n        }\n    }\n\n    /**\n     * Validates that the request should be allowed. Throws an exception if the request should be rejected.\n     */\n    @SuppressWarnings(\"unused\")\n    protected void validateRequest(RestRequest request, RestHandler handler, NodeClient client) throws ElasticsearchStatusException {}\n\n    private void sendFailure(RestChannel responseChannel, Exception e) throws IOException {\n        var restResponse = new RestResponse(responseChannel, e);\n        responseChannel.sendResponse(restResponse);\n        recordRequestMetric(restResponse.status(), requestsCounter);\n    }\n\n    /**\n     * in order to prevent CSRF we have to reject all media types that are from a browser safelist\n     * see https://fetch.spec.whatwg.org/#cors-safelisted-request-header\n     * see https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests\n     * @param request\n     */\n    private static boolean isContentTypeDisallowed(RestRequest request) {\n        return request.getParsedContentType() != null\n            && SAFELISTED_MEDIA_TYPES.contains(request.getParsedContentType().mediaTypeWithoutParameters());\n    }\n\n    private boolean handleNoHandlerFound(\n        ThreadContext threadContext,\n        String rawPath,\n        RestRequest.Method method,\n        String uri,\n        RestChannel channel\n    ) {\n        // Get the map of matching handlers for a request, for the full set of HTTP methods.\n        final Set<RestRequest.Method> validMethodSet = getValidHandlerMethodSet(rawPath);\n        if (validMethodSet.contains(method) == false) {\n            if (method == RestRequest.Method.OPTIONS) {\n                startTrace(threadContext, channel);\n                handleOptionsRequest(channel, validMethodSet);\n                return true;\n            }\n            if (validMethodSet.isEmpty() == false) {\n                // If an alternative handler for an explicit path is registered to a\n                // different HTTP method than the one supplied - return a 405 Method\n                // Not Allowed error.\n                startTrace(threadContext, channel);\n                handleUnsupportedHttpMethod(uri, method, channel, validMethodSet, null);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void startTrace(ThreadContext threadContext, RestChannel channel) {\n        startTrace(threadContext, channel, null);\n    }\n\n    private void startTrace(ThreadContext threadContext, RestChannel channel, String restPath) {\n        final RestRequest req = channel.request();\n        if (restPath == null) {\n            restPath = req.path();\n        }\n        String method = null;\n        try {\n            method = req.method().name();\n        } catch (IllegalArgumentException e) {\n            // Invalid methods throw an exception\n        }\n        String name;\n        if (method != null) {\n            name = method + \" \" + restPath;\n        } else {\n            name = restPath;\n        }\n\n        final Map<String, Object> attributes = Maps.newMapWithExpectedSize(req.getHeaders().size() + 3);\n        req.getHeaders().forEach((key, values) -> {\n            final String lowerKey = key.toLowerCase(Locale.ROOT).replace('-', '_');\n            attributes.put(\"http.request.headers.\" + lowerKey, values == null ? \"\" : String.join(\"; \", values));\n        });\n        attributes.put(\"http.method\", Objects.requireNonNullElse(method, \"<unknown>\"));\n        attributes.put(\"http.url\", Objects.requireNonNullElse(req.uri(), \"<unknown>\"));\n        switch (req.getHttpRequest().protocolVersion()) {\n            case HTTP_1_0 -> attributes.put(\"http.flavour\", \"1.0\");\n            case HTTP_1_1 -> attributes.put(\"http.flavour\", \"1.1\");\n        }\n\n        tracer.startTrace(threadContext, channel.request(), name, attributes);\n    }\n\n    private void traceException(RestChannel channel, Throwable e) {\n        this.tracer.addError(channel.request(), e);\n    }\n\n    private static void sendContentTypeErrorMessage(@Nullable List<String> contentTypeHeader, RestChannel channel) throws IOException {\n        final String errorMessage;\n        if (contentTypeHeader == null) {\n            errorMessage = \"Content-Type header is missing\";\n        } else {\n            errorMessage = \"Content-Type header [\" + Strings.collectionToCommaDelimitedString(contentTypeHeader) + \"] is not supported\";\n        }\n\n        channel.sendResponse(RestResponse.createSimpleErrorResponse(channel, NOT_ACCEPTABLE, errorMessage));\n    }\n\n    private void tryAllHandlers(final RestRequest request, final RestChannel channel, final ThreadContext threadContext) throws Exception {\n        try {\n            validateErrorTrace(request, channel);\n        } catch (IllegalArgumentException e) {\n            startTrace(threadContext, channel);\n            channel.sendResponse(RestResponse.createSimpleErrorResponse(channel, BAD_REQUEST, e.getMessage()));\n            recordRequestMetric(BAD_REQUEST, requestsCounter);\n            return;\n        }\n\n        final String rawPath = request.rawPath();\n        final String uri = request.uri();\n        final RestRequest.Method requestMethod;\n\n        RestApiVersion restApiVersion = request.getRestApiVersion();\n        try {\n            // Resolves the HTTP method and fails if the method is invalid\n            requestMethod = request.method();\n            // Loop through all possible handlers, attempting to dispatch the request\n            Iterator<MethodHandlers> allHandlers = getAllHandlers(request.params(), rawPath);\n            while (allHandlers.hasNext()) {\n                final RestHandler handler;\n                final MethodHandlers handlers = allHandlers.next();\n                if (handlers == null) {\n                    handler = null;\n                } else {\n                    handler = handlers.getHandler(requestMethod, restApiVersion);\n                }\n                if (handler == null) {\n                    if (handleNoHandlerFound(threadContext, rawPath, requestMethod, uri, channel)) {\n                        return;\n                    }\n                } else {\n                    startTrace(threadContext, channel, handlers.getPath());\n                    var decoratedChannel = new MeteringRestChannelDecorator(channel, requestsCounter, handler.getConcreteRestHandler());\n                    maybeAggregateAndDispatchRequest(request, decoratedChannel, handler, handlers, threadContext);\n                    return;\n                }\n            }\n        } catch (final IllegalArgumentException e) {\n            startTrace(threadContext, channel);\n            traceException(channel, e);\n            handleUnsupportedHttpMethod(uri, null, channel, getValidHandlerMethodSet(rawPath), e);\n            return;\n        }\n        // If request has not been handled, fallback to a bad request error.\n        startTrace(threadContext, channel);\n        handleBadRequest(uri, requestMethod, channel);\n    }\n\n    private static void validateErrorTrace(RestRequest request, RestChannel channel) {\n        // error_trace cannot be used when we disable detailed errors\n        // we consume the error_trace parameter first to ensure that it is always consumed\n        if (request.paramAsBoolean(\"error_trace\", ERROR_TRACE_DEFAULT) && channel.detailedErrorsEnabled() == false) {\n            throw new IllegalArgumentException(\"error traces in responses are disabled.\");\n        }\n    }\n\n    Iterator<MethodHandlers> getAllHandlers(@Nullable Map<String, String> requestParamsRef, String rawPath) {\n        final Supplier<Map<String, String>> paramsSupplier;\n        if (requestParamsRef == null) {\n            paramsSupplier = () -> null;\n        } else {\n            // Between retrieving the correct path, we need to reset the parameters,\n            // otherwise parameters are parsed out of the URI that aren't actually handled.\n            final Map<String, String> originalParams = Map.copyOf(requestParamsRef);\n            paramsSupplier = () -> {\n                // PathTrie modifies the request, so reset the params between each iteration\n                requestParamsRef.clear();\n                requestParamsRef.putAll(originalParams);\n                return requestParamsRef;\n            };\n        }\n        // we use rawPath since we don't want to decode it while processing the path resolution\n        // so we can handle things like:\n        // my_index/my_type/http%3A%2F%2Fwww.google.com\n        return handlers.retrieveAll(rawPath, paramsSupplier).iterator();\n    }\n\n    /**\n     * Returns the holder for search usage statistics, to be used to track search usage when parsing\n     * incoming search requests from the relevant REST endpoints. This is exposed for plugins that\n     * expose search functionalities which need to contribute to the search usage statistics.\n     */\n    public SearchUsageHolder getSearchUsageHolder() {\n        return usageService.getSearchUsageHolder();\n    }\n\n    /**\n     * Handle requests to a valid REST endpoint using an unsupported HTTP\n     * method. A 405 HTTP response code is returned, and the response 'Allow'\n     * header includes a list of valid HTTP methods for the endpoint (see\n     * <a href=\"https://tools.ietf.org/html/rfc2616#section-10.4.6\">HTTP/1.1 -\n     * 10.4.6 - 405 Method Not Allowed</a>).\n     */\n    private void handleUnsupportedHttpMethod(\n        String uri,\n        @Nullable RestRequest.Method method,\n        final RestChannel channel,\n        final Set<RestRequest.Method> validMethodSet,\n        @Nullable final IllegalArgumentException exception\n    ) {\n        try {\n            final StringBuilder msg = new StringBuilder();\n            if (exception == null) {\n                msg.append(\"Incorrect HTTP method for uri [\").append(uri);\n                msg.append(\"] and method [\").append(method).append(\"]\");\n            } else {\n                msg.append(exception.getMessage());\n            }\n            if (validMethodSet.isEmpty() == false) {\n                msg.append(\", allowed: \").append(validMethodSet);\n            }\n            RestResponse restResponse = RestResponse.createSimpleErrorResponse(channel, METHOD_NOT_ALLOWED, msg.toString());\n            if (validMethodSet.isEmpty() == false) {\n                restResponse.addHeader(\"Allow\", Strings.collectionToDelimitedString(validMethodSet, \",\"));\n            }\n            channel.sendResponse(restResponse);\n            recordRequestMetric(METHOD_NOT_ALLOWED, requestsCounter);\n        } catch (final IOException e) {\n            logger.warn(\"failed to send bad request response\", e);\n            channel.sendResponse(new RestResponse(INTERNAL_SERVER_ERROR, RestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY));\n            recordRequestMetric(INTERNAL_SERVER_ERROR, requestsCounter);\n        }\n    }\n\n    /**\n     * Handle HTTP OPTIONS requests to a valid REST endpoint. A 200 HTTP\n     * response code is returned, and the response 'Allow' header includes a\n     * list of valid HTTP methods for the endpoint (see\n     * <a href=\"https://tools.ietf.org/html/rfc2616#section-9.2\">HTTP/1.1 - 9.2\n     * - Options</a>).\n     */\n    private void handleOptionsRequest(RestChannel channel, Set<RestRequest.Method> validMethodSet) {\n        RestResponse restResponse = new RestResponse(OK, TEXT_CONTENT_TYPE, BytesArray.EMPTY);\n        // When we have an OPTIONS HTTP request and no valid handlers, simply send OK by default (with the Access Control Origin header\n        // which gets automatically added).\n        if (validMethodSet.isEmpty() == false) {\n            restResponse.addHeader(\"Allow\", Strings.collectionToDelimitedString(validMethodSet, \",\"));\n        }\n        channel.sendResponse(restResponse);\n        recordRequestMetric(OK, requestsCounter);\n    }\n\n    /**\n     * Handle a requests with no candidate handlers (return a 400 Bad Request\n     * error).\n     */\n    private void handleBadRequest(String uri, RestRequest.Method method, RestChannel channel) throws IOException {\n        try (XContentBuilder builder = channel.newErrorBuilder()) {\n            builder.startObject();\n            {\n                builder.field(\"error\", \"no handler found for uri [\" + uri + \"] and method [\" + method + \"]\");\n            }\n            builder.endObject();\n            channel.sendResponse(new RestResponse(BAD_REQUEST, builder));\n            recordRequestMetric(BAD_REQUEST, requestsCounter);\n        }\n    }\n\n    private void handleServerlessRequestToProtectedResource(String uri, RestRequest.Method method, RestChannel channel) throws IOException {\n        String msg = \"uri [\" + uri + \"] with method [\" + method + \"] exists but is not available when running in serverless mode\";\n        sendFailure(channel, new ApiNotAvailableException(msg));\n    }\n\n    /**\n     * Get the valid set of HTTP methods for a REST request.\n     */\n    private Set<RestRequest.Method> getValidHandlerMethodSet(String rawPath) {\n        Set<RestRequest.Method> validMethods = EnumSet.noneOf(RestRequest.Method.class);\n        Iterator<MethodHandlers> allHandlers = getAllHandlers(null, rawPath);\n        while (allHandlers.hasNext()) {\n            final MethodHandlers methodHandlers = allHandlers.next();\n            if (methodHandlers != null) {\n                validMethods.addAll(methodHandlers.getValidMethods());\n            }\n        }\n        return validMethods;\n    }\n\n    private static void recordRequestMetric(RestStatus statusCode, String handlerName, String requestMethod, LongCounter requestsCounter) {\n        try {\n            Map<String, Object> attributes = Map.of(\n                STATUS_CODE_KEY,\n                statusCode.getStatus(),\n                HANDLER_NAME_KEY,\n                handlerName,\n                REQUEST_METHOD_KEY,\n                requestMethod\n            );\n            requestsCounter.incrementBy(1, attributes);\n        } catch (Exception ex) {\n            logger.error(\"Cannot track request status code\", ex);\n        }\n    }\n\n    private static void recordRequestMetric(RestStatus statusCode, LongCounter requestsCounter) {\n        try {\n            Map<String, Object> attributes = Map.of(STATUS_CODE_KEY, statusCode.getStatus());\n            requestsCounter.incrementBy(1, attributes);\n        } catch (Exception ex) {\n            logger.error(\"Cannot track request status code\", ex);\n        }\n    }\n\n    private static class DelegatingRestChannel implements RestChannel {\n\n        private final RestChannel delegate;\n\n        private DelegatingRestChannel(RestChannel delegate) {\n            this.delegate = delegate;\n        }\n\n        @Override\n        public XContentBuilder newBuilder() throws IOException {\n            return delegate.newBuilder();\n        }\n\n        @Override\n        public XContentBuilder newErrorBuilder() throws IOException {\n            return delegate.newErrorBuilder();\n        }\n\n        @Override\n        public XContentBuilder newBuilder(@Nullable XContentType xContentType, boolean useFiltering) throws IOException {\n            return delegate.newBuilder(xContentType, useFiltering);\n        }\n\n        @Override\n        public XContentBuilder newBuilder(XContentType xContentType, XContentType responseContentType, boolean useFiltering)\n            throws IOException {\n            return delegate.newBuilder(xContentType, responseContentType, useFiltering);\n        }\n\n        @Override\n        public XContentBuilder newBuilder(\n            XContentType xContentType,\n            XContentType responseContentType,\n            boolean useFiltering,\n            OutputStream out\n        ) throws IOException {\n            return delegate.newBuilder(xContentType, responseContentType, useFiltering, out);\n        }\n\n        @Override\n        public BytesStream bytesOutput() {\n            return delegate.bytesOutput();\n        }\n\n        @Override\n        public void releaseOutputBuffer() {\n            delegate.releaseOutputBuffer();\n        }\n\n        @Override\n        public RestRequest request() {\n            return delegate.request();\n        }\n\n        @Override\n        public boolean detailedErrorsEnabled() {\n            return delegate.detailedErrorsEnabled();\n        }\n\n        @Override\n        public void sendResponse(RestResponse response) {\n            delegate.sendResponse(response);\n        }\n    }\n\n    private static final class MeteringRestChannelDecorator extends DelegatingRestChannel {\n\n        private final LongCounter requestsCounter;\n        private final RestHandler restHandler;\n\n        private MeteringRestChannelDecorator(RestChannel delegate, LongCounter requestCounter, RestHandler restHandler) {\n            super(delegate);\n            this.requestsCounter = requestCounter;\n            this.restHandler = restHandler;\n        }\n\n        @Override\n        public void sendResponse(RestResponse response) {\n            super.sendResponse(response);\n            recordRequestMetric(response.status(), restHandler.getName(), request().method().name(), requestsCounter);\n        }\n    }\n\n    // exposed for tests; marked as UpdateForV10 because this assertion should have flushed out all double-close bugs by the time v10 is\n    // released so we should be able to drop the tests that check we behave reasonably in production on this impossible path\n    @UpdateForV10(owner = UpdateForV10.Owner.DISTRIBUTED_COORDINATION)\n    static boolean PERMIT_DOUBLE_RESPONSE = false;\n\n    private static final class ResourceHandlingHttpChannel extends DelegatingRestChannel {\n        private final CircuitBreakerService circuitBreakerService;\n        private final int contentLength;\n        private final HttpRouteStatsTracker statsTracker;\n        private final long startTime;\n        private final AtomicBoolean responseSent = new AtomicBoolean();\n\n        ResourceHandlingHttpChannel(\n            RestChannel delegate,\n            CircuitBreakerService circuitBreakerService,\n            int contentLength,\n            MethodHandlers methodHandlers\n        ) {\n            super(delegate);\n            this.circuitBreakerService = circuitBreakerService;\n            this.contentLength = contentLength;\n            this.statsTracker = methodHandlers.statsTracker();\n            this.startTime = rawRelativeTimeInMillis();\n        }\n\n        @Override\n        public void sendResponse(RestResponse response) {\n            boolean success = false;\n            try {\n                // protect against double-response bugs\n                if (responseSent.compareAndSet(false, true) == false) {\n                    final var message = \"have already sent a response to this request, cannot send another\";\n                    assert PERMIT_DOUBLE_RESPONSE : message;\n                    throw new IllegalStateException(message);\n                }\n                inFlightRequestsBreaker(circuitBreakerService).addWithoutBreaking(-contentLength);\n\n                statsTracker.addRequestStats(contentLength);\n                statsTracker.addResponseTime(rawRelativeTimeInMillis() - startTime);\n                if (response.isChunked() == false) {\n                    statsTracker.addResponseStats(response.content().length());\n                } else {\n                    final var responseLengthRecorder = new ResponseLengthRecorder(statsTracker);\n                    final var headers = response.getHeaders();\n                    response = RestResponse.chunked(\n                        response.status(),\n                        new EncodedLengthTrackingChunkedRestResponseBodyPart(response.chunkedContent(), responseLengthRecorder),\n                        Releasables.wrap(responseLengthRecorder, response)\n                    );\n                    for (final var header : headers.entrySet()) {\n                        for (final var value : header.getValue()) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n                super.sendResponse(response);\n                success = true;\n            } finally {\n                if (success == false) {\n                    releaseOutputBuffer();\n                }\n            }\n        }\n\n        private static long rawRelativeTimeInMillis() {\n            return TimeValue.nsecToMSec(System.nanoTime());\n        }\n    }\n\n    private static class ResponseLengthRecorder extends AtomicReference<HttpRouteStatsTracker> implements Releasable {\n        private long responseLength;\n\n        private ResponseLengthRecorder(HttpRouteStatsTracker routeStatsTracker) {\n            super(routeStatsTracker);\n        }\n\n        @Override\n        public void close() {\n            // closed just before sending the last chunk, and also when the whole RestResponse is closed since the client might abort the\n            // connection before we send the last chunk, in which case we won't have recorded the response in the\n            // stats yet; thus we need run-once semantics here:\n            final var routeStatsTracker = getAndSet(null);\n            if (routeStatsTracker != null) {\n                // if we started sending chunks then we're closed on the transport worker, no need for sync\n                assert responseLength == 0L || Transports.assertTransportThread();\n                routeStatsTracker.addResponseStats(responseLength);\n            }\n        }\n\n        void addChunkLength(long chunkLength) {\n            assert chunkLength >= 0L : chunkLength;\n            assert Transports.assertTransportThread(); // always called on the transport worker, no need for sync\n            assert get() != null : \"already closed\";\n            responseLength += chunkLength;\n        }\n    }\n\n    private static class EncodedLengthTrackingChunkedRestResponseBodyPart implements ChunkedRestResponseBodyPart {\n\n        private final ChunkedRestResponseBodyPart delegate;\n        private final ResponseLengthRecorder responseLengthRecorder;\n\n        private EncodedLengthTrackingChunkedRestResponseBodyPart(\n            ChunkedRestResponseBodyPart delegate,\n            ResponseLengthRecorder responseLengthRecorder\n        ) {\n            this.delegate = delegate;\n            this.responseLengthRecorder = responseLengthRecorder;\n        }\n\n        @Override\n        public boolean isPartComplete() {\n            return delegate.isPartComplete();\n        }\n\n        @Override\n        public boolean isLastPart() {\n            return delegate.isLastPart();\n        }\n\n        @Override\n        public void getNextPart(ActionListener<ChunkedRestResponseBodyPart> listener) {\n            delegate.getNextPart(\n                listener.map(continuation -> new EncodedLengthTrackingChunkedRestResponseBodyPart(continuation, responseLengthRecorder))\n            );\n        }\n\n        @Override\n        public ReleasableBytesReference encodeChunk(int sizeHint, Recycler<BytesRef> recycler) throws IOException {\n            final ReleasableBytesReference bytesReference = delegate.encodeChunk(sizeHint, recycler);\n            responseLengthRecorder.addChunkLength(bytesReference.length());\n            if (isPartComplete() && isLastPart()) {\n                responseLengthRecorder.close();\n            }\n            return bytesReference;\n        }\n\n        @Override\n        public String getResponseContentTypeString() {\n            return delegate.getResponseContentTypeString();\n        }\n    }\n\n    private static CircuitBreaker inFlightRequestsBreaker(CircuitBreakerService circuitBreakerService) {\n        // We always obtain a fresh breaker to reflect changes to the breaker configuration.\n        return circuitBreakerService.getBreaker(CircuitBreaker.IN_FLIGHT_REQUESTS);\n    }\n\n    @ServerlessScope(Scope.PUBLIC)\n    private static final class RestFavIconHandler implements RestHandler {\n        @Override\n        public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {\n            channel.sendResponse(new RestResponse(RestStatus.OK, \"image/x-icon\", FAVICON_RESPONSE));\n        }\n    }\n}\n",
    "file_path": "./codebase_small/server/src/main/java/org/elasticsearch/rest/RestController.java"
  }
]