{
  "name": "StreamingXContentResponse",
  "type": "class_full",
  "content": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.rest;\n\nimport org.apache.lucene.util.BytesRef;\nimport org.elasticsearch.action.ActionListener;\nimport org.elasticsearch.action.support.SubscribableListener;\nimport org.elasticsearch.common.bytes.BytesArray;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.collect.Iterators;\nimport org.elasticsearch.common.io.stream.BytesStream;\nimport org.elasticsearch.common.io.stream.RecyclerBytesStreamOutput;\nimport org.elasticsearch.common.recycler.Recycler;\nimport org.elasticsearch.common.xcontent.ChunkedToXContent;\nimport org.elasticsearch.core.AbstractRefCounted;\nimport org.elasticsearch.core.IOUtils;\nimport org.elasticsearch.core.Nullable;\nimport org.elasticsearch.core.RefCounted;\nimport org.elasticsearch.core.Releasable;\nimport org.elasticsearch.core.Releasables;\nimport org.elasticsearch.core.Streams;\nimport org.elasticsearch.transport.Transports;\nimport org.elasticsearch.xcontent.ToXContent;\nimport org.elasticsearch.xcontent.XContentBuilder;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * A REST response with an XContent body to which the caller can write fragments of content in an asynchronous and streaming fashion.\n * <p>\n * Callers submit individual fragments of content using {@link #writeFragment}. Internally, the output entries are held in a queue.\n * If the queue becomes empty then the response transmission is paused until the next entry becomes available.\n * <p>\n * The internal queue is unbounded. It is the caller's responsibility to ensure that the response does not consume an excess of resources\n * while it's being sent.\n * <p>\n * The caller must eventually call {@link StreamingXContentResponse#close} to finish the transmission of the response.\n */\npublic final class StreamingXContentResponse implements Releasable {\n\n    /**\n     * The underlying stream that collects the raw bytes to be transmitted. Mutable, because we collect the contents of each chunk in a\n     * distinct stream that is held in this field while that chunk is under construction.\n     */\n    @Nullable // if there's no chunk under construction\n    private BytesStream targetStream;\n\n    private final XContentBuilder xContentBuilder;\n\n    private final RestChannel restChannel;\n    private final ToXContent.Params params;\n    private final Releasable onCompletion;\n\n    /**\n     * A listener for the next fragment to become available for transmission after a pause. Completed with the newly-created unique active\n     * {@link AvailableFragmentsResponseBodyPart} within {@link #writeFragment}, and  subscribed to via\n     * {@link AvailableFragmentsResponseBodyPart#getNextPart} when the current {@link AvailableFragmentsResponseBodyPart}\n     * becomes inactive because of a transmission pause.\n     */\n    @Nullable // if the first fragment hasn't been sent yet\n    private SubscribableListener<ChunkedRestResponseBodyPart> nextAvailableFragmentListener;\n\n    /**\n     * A resource to be released when the transmission of the current fragment is complete. Note that we may complete the transmission of\n     * multiple fragments at the same time, if they are all processed by one call to {@link AvailableFragmentsResponseBodyPart#encodeChunk}\n     * and transmitted together.\n     */\n    @Nullable // if not currently sending a fragment\n    private Releasable currentFragmentReleasable;\n\n    /**\n     * @param restChannel  The {@link RestChannel} on which to send the response.\n     * @param params       The {@link ToXContent.Params} to control the serialization.\n     * @param onCompletion A resource which is released when the transmission is complete.\n     */\n    public StreamingXContentResponse(RestChannel restChannel, ToXContent.Params params, Releasable onCompletion) throws IOException {\n        this.restChannel = restChannel;\n        this.params = params;\n        this.onCompletion = onCompletion;\n        this.xContentBuilder = restChannel.newBuilder(\n            restChannel.request().getXContentType(),\n            null,\n            true,\n            Streams.noCloseStream(new OutputStream() {\n                @Override\n                public void write(int b) throws IOException {\n                    assert targetStream != null;\n                    targetStream.write(b);\n                }\n\n                @Override\n                public void write(byte[] b, int off, int len) throws IOException {\n                    assert targetStream != null;\n                    targetStream.write(b, off, len);\n                }\n            })\n        );\n    }\n\n    /**\n     * Close this {@link StreamingXContentResponse}, indicating that there will be no more fragments to send.\n     */\n    @Override\n    public void close() {\n        writeFragment(p -> NO_MORE_FRAGMENTS, () -> {\n            if (isRestResponseFinished.compareAndSet(false, true)) {\n                queueRefs.decRef();\n            }\n        });\n    }\n\n    private Iterator<? extends ToXContent> getChunksIterator(StreamingFragment fragment) {\n        return fragment.fragment().toXContentChunked(xContentBuilder.getRestApiVersion(), params);\n    }\n\n    /**\n     * Enqueue the given fragment for transmission.\n     * @param fragment   The fragment to send.\n     * @param releasable A resource which is released when the fragment has been completely processed, i.e. when\n     *                   <ul>\n     *                   <li>it has been fully sent, or</li>\n     *                   <li>the overall response was cancelled before completion and all resources related to the partial transmission of\n     *                   this fragment have been released.</li>\n     *                   </ul>\n     */\n    public void writeFragment(ChunkedToXContent fragment, Releasable releasable) {\n        if (tryAcquireQueueRef()) {\n            try {\n                fragmentQueue.add(new StreamingFragment(fragment, releasable));\n                if (queueLength.getAndIncrement() == 0) {\n                    // There is no active AvailableChunksZipResponseBodyPart, but there is now an entry in the queue, so we must create a\n                    // AvailableChunksZipResponseBodyPart to process it (along with any other entries that are concurrently added to the\n                    // queue). It's safe to mutate releasable and continuationListener here because they are only otherwise accessed by an\n                    // active AvailableChunksZipResponseBodyPart (which does not exist) or when all queueRefs have been released (which they\n                    // have not here).\n                    final var nextFragment = fragmentQueue.poll();\n                    assert nextFragment != null;\n                    final var availableFragments = new AvailableFragmentsResponseBodyPart(getChunksIterator(nextFragment));\n                    assert currentFragmentReleasable == null;\n                    currentFragmentReleasable = nextFragment.releasable();\n                    final var currentAvailableFragmentListener = nextAvailableFragmentListener;\n                    nextAvailableFragmentListener = new SubscribableListener<>();\n                    if (currentAvailableFragmentListener == null) {\n                        // We are not resuming after a pause, this is the first fragment to be sent, so we start the response transmission.\n                        restChannel.sendResponse(RestResponse.chunked(RestStatus.OK, availableFragments, this::restResponseFinished));\n                    } else {\n                        // We are resuming transmission after a pause, so just carry on sending the response body.\n                        assert currentAvailableFragmentListener.isDone() == false;\n                        currentAvailableFragmentListener.onResponse(availableFragments);\n                    }\n                }\n            } finally {\n                queueRefs.decRef();\n            }\n        } else {\n            Releasables.closeExpectNoException(releasable);\n        }\n    }\n\n    /**\n     * A fragment which is ready for transmission, to be stored in {@link #fragmentQueue}.\n     *\n     * @param fragment      The fragment of XContent to send.\n     * @param releasable    A resource to release when this fragment has been fully transmitted, or is no longer required because the\n     *                      transmission was cancelled.\n     */\n    private record StreamingFragment(ChunkedToXContent fragment, Releasable releasable) {}\n\n    /**\n     * Queue of fragments that are ready for transmission.\n     */\n    private final Queue<StreamingFragment> fragmentQueue = new LinkedBlockingQueue<>();\n\n    /**\n     * Upper bound on the number of fragments in the queue, atomically modified to ensure there's only one thread processing the queue\n     * at once.\n     */\n    private final AtomicInteger queueLength = new AtomicInteger();\n\n    /**\n     * Ref-counting for access to the queue, to avoid clearing the queue on abort concurrently with a fragment being sent.\n     */\n    private final RefCounted queueRefs = AbstractRefCounted.of(this::drainQueue);\n\n    /**\n     * Flag to indicate if the request has been aborted, at which point we should stop enqueueing more fragments and promptly clean up the\n     * ones being sent. It's safe to ignore this, but without it in theory a constant stream of calls to {@link #writeFragment} could\n     * prevent {@link #drainQueue} from running for arbitrarily long.\n     */\n    private final AtomicBoolean isRestResponseFinished = new AtomicBoolean();\n\n    private boolean tryAcquireQueueRef() {\n        return isRestResponseFinished.get() == false && queueRefs.tryIncRef();\n    }\n\n    private void restResponseFinished() {\n        assert Transports.assertTransportThread();\n        if (isRestResponseFinished.compareAndSet(false, true)) {\n            queueRefs.decRef();\n        }\n    }\n\n    private void drainQueue() {\n        assert isRestResponseFinished.get();\n        assert queueRefs.hasReferences() == false;\n        final var taskCount = queueLength.get() + 2 /* currentFragmentReleasable and onCompletion */ ;\n        final var releasables = new ArrayList<Releasable>(taskCount);\n        try {\n            releasables.add(currentFragmentReleasable);\n            currentFragmentReleasable = null;\n            StreamingFragment fragment;\n            while ((fragment = fragmentQueue.poll()) != null) {\n                releasables.add(fragment.releasable());\n            }\n            assert fragmentQueue.isEmpty() : fragmentQueue.size(); // no concurrent adds\n            assert releasables.size() == taskCount - 1 || releasables.size() == taskCount - 2 : taskCount + \" vs \" + releasables.size();\n        } finally {\n            releasables.add(onCompletion);\n            Releasables.closeExpectNoException(Releasables.wrap(releasables));\n        }\n    }\n\n    /**\n     * A {@link ChunkedRestResponseBodyPart} which will yield all currently-available fragments by consuming from {@link #fragmentQueue}.\n     * There is only ever at most one active instance of this class at any time, in the sense that one such instance becoming inactive\n     * <i>happens-before</i> the creation of the next instance. One of these parts may send chunks for more than one fragment.\n     */\n    private final class AvailableFragmentsResponseBodyPart implements ChunkedRestResponseBodyPart {\n\n        /**\n         * An iterator over the chunks of the fragment currently being transmitted.\n         */\n        private Iterator<? extends ToXContent> fragmentChunksIterator;\n\n        /**\n         * True when we have run out of chunks ready for immediate transmission, so the response is paused, but we expect to send more data\n         * later.\n         */\n        private boolean isResponsePaused;\n\n        /**\n         * True when we have sent the last chunk of the last fragment, or the response was cancelled.\n         */\n        private boolean isResponseComplete;\n\n        /**\n         * A listener which is created when there are no more available fragments, so transmission is paused, subscribed to in\n         * {@link #getNextPart}, and then completed with the next body part (sequence of fragments, i.e. a new (unique) active\n         * {@link AvailableFragmentsResponseBodyPart}).\n         */\n        private SubscribableListener<ChunkedRestResponseBodyPart> getNextPartListener;\n\n        /**\n         * A cache for an empty list to be used to collect the {@code Releasable} instances to be released when the next chunk has been\n         * fully transmitted. It's a list because a call to {@link #encodeChunk} may yield a chunk that completes several fragments, each of\n         * which has its own resources to release. We cache this value across chunks because most chunks won't release anything, so we can\n         * keep the empty list around for later to save on allocations.\n         */\n        private ArrayList<Releasable> nextReleasablesCache = new ArrayList<>();\n\n        AvailableFragmentsResponseBodyPart(Iterator<? extends ToXContent> fragmentChunksIterator) {\n            this.fragmentChunksIterator = fragmentChunksIterator;\n        }\n\n        /**\n         * @return whether this part of the response is complete\n         */\n        @Override\n        public boolean isPartComplete() {\n            return isResponsePaused || isResponseComplete;\n        }\n\n        @Override\n        public boolean isLastPart() {\n            return isResponseComplete;\n        }\n\n        @Override\n        public void getNextPart(ActionListener<ChunkedRestResponseBodyPart> listener) {\n            assert getNextPartListener != null;\n            getNextPartListener.addListener(listener);\n        }\n\n        /**\n         * Transfer {@link #currentFragmentReleasable} into the supplied collection (i.e. add it to {@code releasables} and then clear\n         * {@link #currentFragmentReleasable}). Called when the last chunk of the current fragment is serialized, so that we\n         * can start serializing chunks of the next fragment straight away whilst delaying the release of the current fragment's resources\n         * until the transmission of the chunk that is currently under construction.\n         */\n        private void transferCurrentFragmentReleasable(ArrayList<Releasable> releasables) {\n            assert queueRefs.hasReferences();\n\n            if (currentFragmentReleasable == null) {\n                return;\n            }\n\n            if (releasables == nextReleasablesCache) {\n                // adding the first value, so we must line up a new cached value for the next caller\n                nextReleasablesCache = new ArrayList<>();\n            }\n\n            releasables.add(currentFragmentReleasable);\n            currentFragmentReleasable = null;\n        }\n\n        @Override\n        public ReleasableBytesReference encodeChunk(int sizeHint, Recycler<BytesRef> recycler) throws IOException {\n            assert Transports.isTransportThread(Thread.currentThread());\n\n            final ArrayList<Releasable> releasables = nextReleasablesCache;\n            assert releasables.isEmpty();\n            try {\n                if (tryAcquireQueueRef()) {\n                    try {\n                        assert queueLength.get() > 0;\n                        // This is the current unique active AvailableFragmentsResponseBodyPart (i.e. queueLength is strictly positive and\n                        // we hold a queueRef), so any concurrent calls to writeFragment() at this point will just add to the queue and\n                        // won't spawn a new AvailableFragmentsResponseBodyPart or mutate any fields.\n\n                        final RecyclerBytesStreamOutput chunkStream = new RecyclerBytesStreamOutput(recycler);\n                        assert targetStream == null;\n                        targetStream = chunkStream;\n\n                        do {\n                            if (fragmentChunksIterator.hasNext()) {\n                                fragmentChunksIterator.next().toXContent(xContentBuilder, params);\n                            } else {\n                                completeCurrentFragment(releasables);\n                            }\n                        } while (isResponseComplete == false && isResponsePaused == false && chunkStream.size() < sizeHint);\n\n                        assert (releasables == nextReleasablesCache) == releasables.isEmpty();\n                        assert nextReleasablesCache.isEmpty();\n\n                        final Releasable chunkStreamReleasable = () -> Releasables.closeExpectNoException(chunkStream);\n                        final var result = new ReleasableBytesReference(\n                            chunkStream.bytes(),\n                            releasables.isEmpty()\n                                ? chunkStreamReleasable\n                                : Releasables.wrap(Iterators.concat(Iterators.single(chunkStreamReleasable), releasables.iterator()))\n                        );\n                        targetStream = null;\n                        return result;\n                    } finally {\n                        queueRefs.decRef();\n                    }\n                } else {\n                    // request aborted, nothing more to send (queue is being cleared by queueRefs#closeInternal)\n                    isResponseComplete = true;\n                    return new ReleasableBytesReference(BytesArray.EMPTY, () -> {});\n                }\n            } catch (Exception e) {\n                logger.error(\"failure encoding chunk\", e);\n                throw e;\n            } finally {\n                if (targetStream != null) {\n                    assert false : \"failure encoding chunk\";\n                    IOUtils.closeWhileHandlingException(targetStream, Releasables.wrap(releasables));\n                    targetStream = null;\n                }\n            }\n        }\n\n        private void completeCurrentFragment(ArrayList<Releasable> releasables) throws IOException {\n            transferCurrentFragmentReleasable(releasables);\n            final var localNextAvailableFragmentListener = nextAvailableFragmentListener; // read before queue len decr\n            final var newQueueLength = queueLength.decrementAndGet();\n            if (fragmentChunksIterator == NO_MORE_FRAGMENTS) {\n                // The current fragment is the last-fragment sentinel, so we stop processing the queue completely. Note\n                // that closing the XContentBuilder here ensures that the response is well-formed - it's up to the\n                // caller to ensure this, even if errors occur.\n                xContentBuilder.close();\n                isResponseComplete = true;\n            } else if (newQueueLength == 0) {\n                // The current fragment is complete, but the next fragment isn't available yet, so we pause\n                // transmission. This means we are no longer an active AvailableFragmentsResponseBodyPart, so any\n                // concurrent calls to writeFragment() at this point will now spawn a new\n                // AvailableFragmentsResponseBodyPart to take our place.\n                xContentBuilder.flush();\n                isResponsePaused = true;\n                assert getNextPartListener == null;\n                assert localNextAvailableFragmentListener != null;\n                // Calling our getNextPart() will eventually yield the next fragment supplied to writeFragment():\n                getNextPartListener = localNextAvailableFragmentListener;\n            } else {\n                // The current fragment is complete, and the next fragment is already available, so we start sending its\n                // chunks too. This means we're still the unique active AvailableFragmentsResponseBodyPart. We re-use\n                // this AvailableFragmentsResponseBodyPart instance rather than creating a new one to avoid unnecessary\n                // allocations.\n\n                final var nextFragment = fragmentQueue.poll();\n                assert nextFragment != null;\n                currentFragmentReleasable = nextFragment.releasable();\n                fragmentChunksIterator = getChunksIterator(nextFragment);\n            }\n        }\n\n        @Override\n        public String getResponseContentTypeString() {\n            return xContentBuilder.getResponseContentTypeString();\n        }\n    }\n\n    /**\n     * Sentinel fragment indicating the end of the response.\n     */\n    private static final Iterator<? extends ToXContent> NO_MORE_FRAGMENTS = new Iterator<>() {\n        @Override\n        public boolean hasNext() {\n            return false;\n        }\n\n        @Override\n        public ToXContent next() {\n            assert false : \"not called\";\n            return ToXContent.EMPTY;\n        }\n    };\n}\n",
  "file_path": "./codebase_small/server/src/main/java/org/elasticsearch/rest/StreamingXContentResponse.java"
}