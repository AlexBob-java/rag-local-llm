[
  {
    "name": "RestContentAggregator",
    "type": "class",
    "content": "public class RestContentAggregator {\n\n}",
    "file_path": ""
  },
  {
    "name": "replaceBody",
    "type": "function",
    "content": "\n    private static void replaceBody(RestRequest restRequest, ReleasableBytesReference aggregate) {\n        restRequest.getHttpRequest().setBody(new HttpBody.ByteRefHttpBody(aggregate));\n    }\n",
    "file_path": ""
  },
  {
    "name": "aggregate",
    "type": "function",
    "content": "\n    public static void aggregate(RestRequest restRequest, Consumer<RestRequest> resultConsumer) {\n        final var httpRequest = restRequest.getHttpRequest();\n        switch(httpRequest.body()) {\n            case HttpBody.Full full -> resultConsumer.accept(restRequest);\n            case HttpBody<｜begin▁of▁sentence｜> Stream stream -> {\n                final var aggregationHandler = new AggregationChunkHandler(restRequest, resultConsumer);\n                stream.setHandler(aggregationHandler);\n                stream.next();\n             }\n         }\n    }\n",
    "file_path": ""
  },
  {
    "name": "AggregationChunkHandler",
    "type": "class",
    "content": "\n    private static class AggregationChunkHandler implements HttpBody.ChunkHandler {\n        final RestRequest restRequest;\n        final Consumer<RestRequest> resultConsumer;\n        final HttpBody.Stream stream;\n        boolean closing;\n        ArrayList<ReleasableBytesReference> chunks;\n\n        private AggregationChunkHandler(RestRequest restRequest, Consumer<RestRequest> resultConsumer) {\n            this.restRequest = restRequest;\n            this.resultConsumer = resultConsumer;\n            this.stream = restRequest.getHttpRequest().body().asStream();\n         }\n\n        @Override\n        public void onNext(ReleasableBytesReference chunk, boolean isLast) {\n            if (closing){\n                chunk.close();\n                return;\n             }\n            if (!isLast) {\n                if (chunks == null){\n                    chunks = new ArrayList<>();  // allocate array only when there is more than one chunk\n                 }\\n                chunks.add(chunk);\\n                stream.next();\n             } else {\n                if (chunks == null){\n                    replaceBody(restRequest, chunk);\n                 } else {\n                    chunks.add(chunk);\\n                    var comp = CompositeBytesReference.of(chunks.toArray(new ReleasableBytesReference[0]));\\n                    var relComp = new ReleasableBytesReference(comp, Releasables.wrap(chunks));\n                    replaceBody(restRequest, relComp);\n                }\n                chunks = null;\n                closing = true;\n                resultConsumer.accept(restRequest);\n             }\\n        }\n\n        @Override\n        public void close() {\n            if (!closing) {\n                closing = true;\n                if (chunks != null){\n                    Releasables.close(chunks);\n                    chunks = null;\n                 }\\n             }\n        }\n    }\n",
    "file_path": ""
  }
]