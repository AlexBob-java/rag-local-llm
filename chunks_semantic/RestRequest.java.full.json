{
  "name": "RestRequest",
  "type": "class_full",
  "content": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.rest;\n\nimport org.apache.lucene.util.SetOnce;\nimport org.elasticsearch.ElasticsearchParseException;\nimport org.elasticsearch.ElasticsearchStatusException;\nimport org.elasticsearch.common.Strings;\nimport org.elasticsearch.common.ValidationException;\nimport org.elasticsearch.common.bytes.BytesArray;\nimport org.elasticsearch.common.bytes.BytesReference;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.unit.ByteSizeValue;\nimport org.elasticsearch.common.xcontent.XContentHelper;\nimport org.elasticsearch.core.Booleans;\nimport org.elasticsearch.core.CheckedConsumer;\nimport org.elasticsearch.core.Nullable;\nimport org.elasticsearch.core.RestApiVersion;\nimport org.elasticsearch.core.TimeValue;\nimport org.elasticsearch.core.Tuple;\nimport org.elasticsearch.http.HttpBody;\nimport org.elasticsearch.http.HttpChannel;\nimport org.elasticsearch.http.HttpRequest;\nimport org.elasticsearch.logging.LogManager;\nimport org.elasticsearch.logging.Logger;\nimport org.elasticsearch.telemetry.tracing.Traceable;\nimport org.elasticsearch.xcontent.ParsedMediaType;\nimport org.elasticsearch.xcontent.ToXContent;\nimport org.elasticsearch.xcontent.XContentParser;\nimport org.elasticsearch.xcontent.XContentParserConfiguration;\nimport org.elasticsearch.xcontent.XContentType;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.regex.Pattern;\n\nimport static org.elasticsearch.common.unit.ByteSizeValue.parseBytesSizeValue;\nimport static org.elasticsearch.core.TimeValue.parseTimeValue;\n\npublic class RestRequest implements ToXContent.Params, Traceable {\n\n    private static final Logger logger = LogManager.getLogger(RestRequest.class);\n\n    /**\n     * Internal marker request parameter to indicate that a request was made in serverless mode. Use this parameter, together with\n     * {@link #OPERATOR_REQUEST} if you need to toggle behavior for serverless, for example to enforce partial API restrictions\n     * (prevent request fields, omit response fields) for an API.\n     * Requests not made in serverless mode, will *not* have this parameter set.\n     * Given a request instance, you can use {@link #isServerlessRequest()} to determine if the parameter is set or not.\n     * This is also available from {@code ToXContent.Params}. For example:\n     * {@code params.paramAsBoolean(RestRequest.SERVERLESS_REQUEST, false)}\n     */\n    public static final String SERVERLESS_REQUEST = \"serverlessRequest\";\n    /**\n     * Internal marker request parameter to indicate that a request was made by an operator user.\n     * Requests made by regular users (users without operator privileges), will *not* have this parameter set.\n     * Given a request instance, you can use {@link #isOperatorRequest()} to determine if the parameter is set or not.\n     * This is also available from {@code ToXContent.Params}. For example:\n     * {@code params.paramAsBoolean(RestRequest.OPERATOR_REQUEST, false)}\n     */\n    public static final String OPERATOR_REQUEST = \"operatorRequest\";\n\n    /**\n     * Internal request parameters used as markers to indicate various operations modes such as serverless mode, or operator mode.\n     * These can never be set directly by end-users. Instead, they are set internally by Elasticsearch and must be supported by all\n     * request handlers.\n     */\n    public static final Set<String> INTERNAL_MARKER_REQUEST_PARAMETERS = Set.of(SERVERLESS_REQUEST, OPERATOR_REQUEST);\n    // tchar pattern as defined by RFC7230 section 3.2.6\n    private static final Pattern TCHAR_PATTERN = Pattern.compile(\"[a-zA-Z0-9!#\\$%&'*+\\\\-.\\\\^_`|~]+\");\n\n    private static final AtomicLong requestIdGenerator = new AtomicLong();\n\n    private final XContentParserConfiguration parserConfig;\n    private final Map<String, String> params;\n    private final Map<String, List<String>> headers;\n    private final String rawPath;\n    private final Set<String> consumedParams = new HashSet<>();\n    private final SetOnce<XContentType> xContentType = new SetOnce<>();\n    private final HttpChannel httpChannel;\n    private final ParsedMediaType parsedAccept;\n    private final ParsedMediaType parsedContentType;\n    private final Optional<RestApiVersion> restApiVersion;\n    private HttpRequest httpRequest;\n\n    private boolean contentConsumed = false;\n\n    private final long requestId;\n\n    public boolean isContentConsumed() {\n        return contentConsumed;\n    }\n\n    @SuppressWarnings(\"this-escape\")\n    protected RestRequest(\n        XContentParserConfiguration parserConfig,\n        Map<String, String> params,\n        String rawPath,\n        Map<String, List<String>> headers,\n        HttpRequest httpRequest,\n        HttpChannel httpChannel\n    ) {\n        this(parserConfig, params, rawPath, headers, httpRequest, httpChannel, requestIdGenerator.incrementAndGet());\n    }\n\n    @SuppressWarnings(\"this-escape\")\n    private RestRequest(\n        XContentParserConfiguration parserConfig,\n        Map<String, String> params,\n        String rawPath,\n        Map<String, List<String>> headers,\n        HttpRequest httpRequest,\n        HttpChannel httpChannel,\n        long requestId\n    ) {\n        try {\n            this.parsedAccept = parseHeaderWithMediaType(httpRequest.getHeaders(), \"Accept\");\n        } catch (IllegalArgumentException e) {\n            throw new MediaTypeHeaderException(e, \"Accept\");\n        }\n        try {\n            this.parsedContentType = parseHeaderWithMediaType(httpRequest.getHeaders(), \"Content-Type\");\n            if (parsedContentType != null) {\n                this.xContentType.set(parsedContentType.toMediaType(XContentType.MEDIA_TYPE_REGISTRY));\n            }\n        } catch (IllegalArgumentException e) {\n            throw new MediaTypeHeaderException(e, \"Content-Type\");\n        }\n        this.httpRequest = httpRequest;\n        try {\n            this.restApiVersion = RestCompatibleVersionHelper.getCompatibleVersion(parsedAccept, parsedContentType, hasContent());\n        } catch (ElasticsearchStatusException e) {\n            throw new MediaTypeHeaderException(e, \"Accept\", \"Content-Type\");\n        }\n\n        var effectiveApiVersion = this.getRestApiVersion();\n        this.parserConfig = parserConfig.restApiVersion().equals(effectiveApiVersion)\n            ? parserConfig\n            : parserConfig.withRestApiVersion(effectiveApiVersion);\n        this.httpChannel = httpChannel;\n        this.params = params;\n        this.rawPath = rawPath;\n        this.headers = Collections.unmodifiableMap(headers);\n        this.requestId = requestId;\n    }\n\n    protected RestRequest(RestRequest other) {\n        assert other.parserConfig.restApiVersion().equals(other.getRestApiVersion());\n        this.parsedAccept = other.parsedAccept;\n        this.parsedContentType = other.parsedContentType;\n        if (other.xContentType.get() != null) {\n            this.xContentType.set(other.xContentType.get());\n        }\n        this.restApiVersion = other.restApiVersion;\n        this.parserConfig = other.parserConfig;\n        this.httpRequest = other.httpRequest;\n        this.httpChannel = other.httpChannel;\n        this.params = other.params;\n        this.rawPath = other.rawPath;\n        this.headers = other.headers;\n        this.requestId = other.requestId;\n    }\n\n    private static @Nullable ParsedMediaType parseHeaderWithMediaType(Map<String, List<String>> headers, String headerName) {\n        // TODO: make all usages of headers case-insensitive\n        List<String> header = headers.get(headerName);\n        if (header == null || header.isEmpty()) {\n            return null;\n        } else if (header.size() > 1) {\n            throw new IllegalArgumentException(\"Incorrect header [\" + headerName + \"]. Only one value should be provided\");\n        }\n        String rawContentType = header.get(0);\n        if (Strings.hasText(rawContentType)) {\n            return ParsedMediaType.parseMediaType(rawContentType);\n        } else {\n            throw new IllegalArgumentException(\"Header [\" + headerName + \"] cannot be empty.\");\n        }\n    }\n\n    /**\n     * Creates a new REST request.\n     *\n     * @throws BadParameterException if the parameters can not be decoded\n     * @throws MediaTypeHeaderException if the Content-Type or Accept header can not be parsed\n     */\n    public static RestRequest request(XContentParserConfiguration parserConfig, HttpRequest httpRequest, HttpChannel httpChannel) {\n        Map<String, String> params = params(httpRequest.uri());\n        return new RestRequest(\n            parserConfig,\n            params,\n            httpRequest.rawPath(),\n            httpRequest.getHeaders(),\n            httpRequest,\n            httpChannel,\n            requestIdGenerator.incrementAndGet()\n        );\n    }\n\n    private static Map<String, String> params(final String uri) {\n        final Map<String, String> params = new HashMap<>();\n        int index = uri.indexOf('?');\n        if (index >= 0) {\n            try {\n                RestUtils.decodeQueryString(uri, index + 1, params);\n            } catch (final IllegalArgumentException e) {\n                throw new BadParameterException(e);\n            }\n        }\n        return params;\n    }\n\n    /**\n     * Creates a new REST request. The path is not decoded so this constructor will not throw a\n     * {@link BadParameterException}.\n     *\n     * @throws MediaTypeHeaderException if the Content-Type or Accept header can not be parsed\n     */\n    public static RestRequest requestWithoutParameters(\n        XContentParserConfiguration parserConfig,\n        HttpRequest httpRequest,\n        HttpChannel httpChannel\n    ) {\n        Map<String, String> params = Collections.emptyMap();\n        return new RestRequest(\n            parserConfig,\n            params,\n            httpRequest.uri(),\n            httpRequest.getHeaders(),\n            httpRequest,\n            httpChannel,\n            requestIdGenerator.incrementAndGet()\n        );\n    }\n\n    public enum Method {\n        GET,\n        POST,\n        PUT,\n        DELETE,\n        OPTIONS,\n        HEAD,\n        PATCH,\n        TRACE,\n        CONNECT\n    }\n\n    /**\n     * Returns the HTTP method used in the REST request.\n     *\n     * @return the {@link Method} used in the REST request\n     * @throws IllegalArgumentException if the HTTP method is invalid\n     */\n    public Method method() {\n        return httpRequest.method();\n    }\n\n    /**\n     * The uri of the rest request, with the query string.\n     */\n    public String uri() {\n        return httpRequest.uri();\n    }\n\n    /**\n     * The non decoded, raw path provided.\n     */\n    public String rawPath() {\n        return rawPath;\n    }\n\n    /**\n     * The path part of the URI (without the query string), decoded.\n     */\n    public final String path() {\n        return RestUtils.decodeComponent(rawPath());\n    }\n\n    public boolean hasContent() {\n        return httpRequest.hasContent();\n    }\n\n    public int contentLength() {\n        return httpRequest.body().asFull().bytes().length();\n    }\n\n    public boolean isFullContent() {\n        return httpRequest.body().isFull();\n    }\n\n    /**\n     * Returns a direct reference to the network buffer containing the request body. The HTTP layers will release their references to this\n     * buffer as soon as they have finished the synchronous steps of processing the request on the network thread, which will by default\n     * release the buffer back to the pool where it may be re-used for another request. If you need to keep the buffer alive past the end of\n     * these synchronous steps, acquire your own reference to this buffer and release it once it's no longer needed.\n     */\n    public ReleasableBytesReference content() {\n        this.contentConsumed = true;\n        var bytes = httpRequest.body().asFull().bytes();\n        if (bytes.hasReferences() == false) {\n            var e = new IllegalStateException(\"http releasable content accessed after release\");\n            logger.error(e.getMessage(), e);\n            assert false : e;\n            throw e;\n        }\n        return bytes;\n    }\n\n    public boolean isStreamedContent() {\n        return httpRequest.body().isStream();\n    }\n\n    public HttpBody.Stream contentStream() {\n        this.contentConsumed = true;\n        return httpRequest.body().asStream();\n    }\n\n    public void ensureContent() {\n        if (hasContent() == false) {\n            throw new ElasticsearchParseException(\"request body is required\");\n        } else if (xContentType.get() == null) {\n            throwValidationException(\"unknown content type\");\n        }\n    }\n\n    /**\n     * Returns reference to the network buffer of HTTP content or throw an exception if the body or content type is missing.\n     * See {@link #content()}.\n     */\n    public ReleasableBytesReference requiredContent() {\n        ensureContent();\n        return content();\n    }\n\n    private static void throwValidationException(String msg) {\n        ValidationException unknownContentType = new ValidationException();\n        unknownContentType.addValidationError(msg);\n        throw unknownContentType;\n    }\n\n    /**\n     * Get the value of the header or {@code null} if not found. This method only retrieves the first header value if multiple values are\n     * sent. Use of {@link #getAllHeaderValues(String)} should be preferred\n     */\n    public final String header(String name) {\n        List<String> values = headers.get(name);\n        if (values != null && values.isEmpty() == false) {\n            return values.get(0);\n        }\n        return null;\n    }\n\n    /**\n     * Get all values for the header or {@code null} if the header was not found\n     */\n    public final List<String> getAllHeaderValues(String name) {\n        List<String> values = headers.get(name);\n        if (values != null) {\n            return Collections.unmodifiableList(values);\n        }\n        return null;\n    }\n\n    /**\n     * Get all of the headers and values associated with the headers. Modifications of this map are not supported.\n     */\n    public final Map<String, List<String>> getHeaders() {\n        return headers;\n    }\n\n    public final long getRequestId() {\n        return requestId;\n    }\n\n    /**\n     * The {@link XContentType} that was parsed from the {@code Content-Type} header. This value will be {@code null} in the case of\n     * a request without a valid {@code Content-Type} header, a request without content ({@link #hasContent()}, or a plain text request\n     */\n    @Nullable\n    public final XContentType getXContentType() {\n        return xContentType.get();\n    }\n\n    public HttpChannel getHttpChannel() {\n        return httpChannel;\n    }\n\n    public HttpRequest getHttpRequest() {\n        return httpRequest;\n    }\n\n    public final boolean hasParam(String key) {\n        return params.containsKey(key);\n    }\n\n    @Override\n    public final String param(String key) {\n        consumedParams.add(key);\n        return params.get(key);\n    }\n\n    @Override\n    public final String param(String key, String defaultValue) {\n        consumedParams.add(key);\n        String value = params.get(key);\n        if (value == null) {\n            return defaultValue;\n        }\n        return value;\n    }\n\n    public Map<String, String> params() {\n        return params;\n    }\n\n    /**\n     * Returns a list of parameters that have been consumed. This method returns a copy, callers\n     * are free to modify the returned list.\n     *\n     * @return the list of currently consumed parameters.\n     */\n    List<String> consumedParams() {\n        return new ArrayList<>(consumedParams);\n    }\n\n    /**\n     * Returns a list of parameters that have not yet been consumed. This method returns a copy,\n     * callers are free to modify the returned list.\n     *\n     * @return the list of currently unconsumed parameters.\n     */\n    List<String> unconsumedParams() {\n        return params.keySet().stream().filter(p -> consumedParams.contains(p) == false).toList();\n    }\n\n    public float paramAsFloat(String key, float defaultValue) {\n        String sValue = param(key);\n        if (sValue == null) {\n            return defaultValue;\n        }\n        try {\n            return Float.parseFloat(sValue);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"Failed to parse float parameter [\" + key + \"] with value [\" + sValue + \"]\", e);\n        }\n    }\n\n    public double paramAsDouble(String key, double defaultValue) {\n        String sValue = param(key);\n        if (sValue == null) {\n            return defaultValue;\n        }\n        try {\n            return Double.parseDouble(sValue);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"Failed to parse double parameter [\" + key + \"] with value [\" + sValue + \"]\", e);\n        }\n    }\n\n    public int paramAsInt(String key, int defaultValue) {\n        String sValue = param(key);\n        if (sValue == null) {\n            return defaultValue;\n        }\n        try {\n            return Integer.parseInt(sValue);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"Failed to parse int parameter [\" + key + \"] with value [\" + sValue + \"]\", e);\n        }\n    }\n\n    public Integer paramAsInteger(String key, Integer defaultValue) {\n        String sValue = param(key);\n        if (sValue == null) {\n            return defaultValue;\n        }\n        try {\n            return Integer.valueOf(sValue);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"Failed to parse int parameter [\" + key + \"] with value [\" + sValue + \"]\", e);\n        }\n    }\n\n    public long paramAsLong(String key, long defaultValue) {\n        String sValue = param(key);\n        if (sValue == null) {\n            return defaultValue;\n        }\n        try {\n            return Long.parseLong(sValue);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"Failed to parse long parameter [\" + key + \"] with value [\" + sValue + \"]\", e);\n        }\n    }\n\n    @Override\n    public boolean paramAsBoolean(String key, boolean defaultValue) {\n        String rawParam = param(key);\n        // Treat empty string as true because that allows the presence of the url parameter to mean \"turn this on\"\n        if (rawParam != null && rawParam.length() == 0) {\n            return true;\n        } else {\n            return Booleans.parseBoolean(rawParam, defaultValue);\n        }\n    }\n\n    @Override\n    public Boolean paramAsBoolean(String key, Boolean defaultValue) {\n        return Booleans.parseBoolean(param(key), defaultValue);\n    }\n\n    public TimeValue paramAsTime(String key, TimeValue defaultValue) {\n        return parseTimeValue(param(key), defaultValue, key);\n    }\n\n    public ByteSizeValue paramAsSize(String key, ByteSizeValue defaultValue) {\n        return parseBytesSizeValue(param(key), defaultValue, key);\n    }\n\n    public String[] paramAsStringArray(String key, String[] defaultValue) {\n        String value = param(key);\n        if (value == null) {\n            return defaultValue;\n        }\n        return Strings.splitStringByCommaToArray(value);\n    }\n\n    public String[] paramAsStringArrayOrEmptyIfAll(String key) {\n        String[] params = paramAsStringArray(key, Strings.EMPTY_ARRAY);\n        if (Strings.isAllOrWildcard(params)) {\n            return Strings.EMPTY_ARRAY;\n        }\n        return params;\n    }\n\n    /**\n     * Get the configuration that should be used to create {@link XContentParser} from this request.\n     */\n    public XContentParserConfiguration contentParserConfig() {\n        return parserConfig;\n    }\n\n    /**\n     * A parser for the contents of this request if there is a body, otherwise throws an {@link ElasticsearchParseException}. Use\n     * {@link #applyContentParser(CheckedConsumer)} if you want to gracefully handle when the request doesn't have any contents. Use\n     * {@link #contentOrSourceParamParser()} for requests that support specifying the request body in the {@code source} param.\n     */\n    public final XContentParser contentParser() throws IOException {\n        return contentParser(parserConfig);\n    }\n\n    private XContentParser contentParser(XContentParserConfiguration parserConfig) throws IOException {\n        BytesReference content = requiredContent(); // will throw exception if body or content type missing\n        return XContentHelper.createParserNotCompressed(parserConfig, content, xContentType.get());\n    }\n\n    /**\n     * If there is any content then call {@code applyParser} with the parser modified by {@code includeSourceOnError}, otherwise do nothing.\n     */\n    public final void applyContentParser(boolean includeSourceOnError, CheckedConsumer<XContentParser, IOException> applyParser)\n        throws IOException {\n        if (hasContent()) {\n            try (XContentParser parser = contentParser(parserConfig.withIncludeSourceOnError(includeSourceOnError))) {\n                applyParser.accept(parser);\n            }\n        }\n    }\n\n    /**\n     * If there is any content then call {@code applyParser} with the parser, otherwise do nothing.\n     */\n    public final void applyContentParser(CheckedConsumer<XContentParser, IOException> applyParser) throws IOException {\n        if (hasContent()) {\n            try (XContentParser parser = contentParser(parserConfig)) {\n                applyParser.accept(parser);\n            }\n        }\n    }\n\n    /**\n     * Does this request have content or a {@code source} parameter? Use this instead of {@link #hasContent()} if this\n     * {@linkplain RestHandler} treats the {@code source} parameter like the body content.\n     */\n    public final boolean hasContentOrSourceParam() {\n        return hasContent() || hasParam(\"source\");\n    }\n\n    /**\n     * A parser for the contents of this request if it has contents, otherwise a parser for the {@code source} parameter if there is one,\n     * otherwise throws an {@link ElasticsearchParseException}. Use {@link #withContentOrSourceParamParserOrNull(CheckedConsumer)} instead\n     * if you need to handle the absence request content gracefully.\n     */\n    public final XContentParser contentOrSourceParamParser() throws IOException {\n        Tuple<XContentType, ReleasableBytesReference> tuple = contentOrSourceParam();\n        return XContentHelper.createParserNotCompressed(parserConfig, tuple.v2(), tuple.v1().xContent().type());\n    }\n\n    /**\n     * Call a consumer with the parser for the contents of this request if it has contents, otherwise with a parser for the {@code source}\n     * parameter if there is one, otherwise with {@code null}. Use {@link #contentOrSourceParamParser()} if you should throw an exception\n     * back to the user when there isn't request content.\n     */\n    public final void withContentOrSourceParamParserOrNull(CheckedConsumer<XContentParser, IOException> withParser) throws IOException {\n        if (hasContentOrSourceParam()) {\n            Tuple<XContentType, ReleasableBytesReference> tuple = contentOrSourceParam();\n            try (XContentParser parser = XContentHelper.createParserNotCompressed(parserConfig, tuple.v2(), tuple.v1())) {\n                withParser.accept(parser);\n            }\n        } else {\n            withParser.accept(null);\n        }\n    }\n\n    /**\n     * Get the content of the request or the contents of the {@code source} param or throw an exception if both are missing.\n     * Prefer {@link #contentOrSourceParamParser()} or {@link #withContentOrSourceParamParserOrNull(CheckedConsumer)} if you need a parser.\n     */\n    public final Tuple<XContentType, ReleasableBytesReference> contentOrSourceParam() {\n        if (hasContentOrSourceParam() == false) {\n            throw new ElasticsearchParseException(\"request body or source parameter is required\");\n        } else if (hasContent()) {\n            return new Tuple<>(xContentType.get(), requiredContent());\n        }\n        String source = param(\"source\");\n        String typeParam = param(\"source_content_type\");\n        if (source == null || typeParam == null) {\n            throwValidationException(\"source and source_content_type parameters are required\");\n        }\n        BytesArray bytes = new BytesArray(source);\n        final XContentType xContentType = parseContentType(Collections.singletonList(typeParam));\n        if (xContentType == null) {\n            throwValidationException(\"Unknown value for source_content_type [\" + typeParam + \"]\");\n        }\n        return new Tuple<>(xContentType, ReleasableBytesReference.wrap(bytes));\n    }\n\n    public ParsedMediaType getParsedAccept() {\n        return parsedAccept;\n    }\n\n    public ParsedMediaType getParsedContentType() {\n        return parsedContentType;\n    }\n\n    /**\n     * Parses the given content type string for the media type. This method currently ignores parameters.\n     */\n    // TODO stop ignoring parameters such as charset...\n    public static XContentType parseContentType(List<String> header) {\n        if (header == null || header.isEmpty()) {\n            return null;\n        } else if (header.size() > 1) {\n            throw new IllegalArgumentException(\"only one Content-Type header should be provided\");\n        }\n\n        String rawContentType = header.get(0);\n        final String[] elements = rawContentType.split(\"[ \\t]*;\");\n        if (elements.length > 0) {\n            final String[] splitMediaType = elements[0].split(\"/\");\n            if (splitMediaType.length == 2\n                && TCHAR_PATTERN.matcher(splitMediaType[0]).matches()\n                && TCHAR_PATTERN.matcher(splitMediaType[1].trim()).matches()) {\n                return XContentType.fromMediaType(elements[0]);\n            } else {\n                throw new IllegalArgumentException(\"invalid Content-Type header [\" + rawContentType + \"]\");\n            }\n        }\n        throw new IllegalArgumentException(\"empty Content-Type header\");\n    }\n\n    /**\n     * The requested version of the REST API.\n     */\n    public RestApiVersion getRestApiVersion() {\n        return restApiVersion.orElse(RestApiVersion.current());\n    }\n\n    public boolean hasExplicitRestApiVersion() {\n        return restApiVersion.isPresent();\n    }\n\n    /**\n     * See {@link #SERVERLESS_REQUEST}\n     */\n    public void markAsServerlessRequest() {\n        setParamTrueOnceAndConsume(SERVERLESS_REQUEST);\n    }\n\n    /**\n     * See {@link #SERVERLESS_REQUEST}\n     */\n    public boolean isServerlessRequest() {\n        return paramAsBoolean(SERVERLESS_REQUEST, false);\n    }\n\n    /**\n     * See {@link #OPERATOR_REQUEST}\n     */\n    public void markAsOperatorRequest() {\n        setParamTrueOnceAndConsume(OPERATOR_REQUEST);\n    }\n\n    /**\n     * See {@link #OPERATOR_REQUEST}\n     */\n    public boolean isOperatorRequest() {\n        return paramAsBoolean(OPERATOR_REQUEST, false);\n    }\n\n    private void setParamTrueOnceAndConsume(String param) {\n        if (params.containsKey(param)) {\n            throw new IllegalArgumentException(\"The parameter [\" + param + \"] is already defined.\");\n        }\n        params.put(param, \"true\");\n        // this parameter is intended be consumed via ToXContent.Params.param(..), not this.params(..) so don't require it is consumed here\n        consumedParams.add(param);\n    }\n\n    @Override\n    public String getSpanId() {\n        return \"rest-\" + getRequestId();\n    }\n\n    public static class MediaTypeHeaderException extends RuntimeException {\n\n        private final String message;\n        private final Set<String> failedHeaderNames;\n\n        MediaTypeHeaderException(final RuntimeException cause, String... failedHeaderNames) {\n            super(cause);\n            this.failedHeaderNames = Set.of(failedHeaderNames);\n            this.message = \"Invalid media-type value on headers \" + this.failedHeaderNames;\n        }\n\n        public Set<String> getFailedHeaderNames() {\n            return failedHeaderNames;\n        }\n\n        @Override\n        public String getMessage() {\n            return message;\n        }\n    }\n\n    public static class BadParameterException extends RuntimeException {\n\n        BadParameterException(final IllegalArgumentException cause) {\n            super(cause);\n        }\n\n    }\n\n}\n",
  "file_path": "./codebase_small/server/src/main/java/org/elasticsearch/rest/RestRequest.java"
}