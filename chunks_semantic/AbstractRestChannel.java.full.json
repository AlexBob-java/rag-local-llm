{
  "name": "AbstractRestChannel",
  "type": "class_full",
  "content": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\npackage org.elasticsearch.rest;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.elasticsearch.common.Strings;\nimport org.elasticsearch.common.io.stream.BytesStream;\nimport org.elasticsearch.common.io.stream.BytesStreamOutput;\nimport org.elasticsearch.core.Nullable;\nimport org.elasticsearch.xcontent.ParsedMediaType;\nimport org.elasticsearch.xcontent.XContentBuilder;\nimport org.elasticsearch.xcontent.XContentFactory;\nimport org.elasticsearch.xcontent.XContentType;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Predicate;\n\nimport static java.util.stream.Collectors.toSet;\n\npublic abstract class AbstractRestChannel implements RestChannel {\n\n    private static final Logger logger = LogManager.getLogger(AbstractRestChannel.class);\n\n    private static final Predicate<String> INCLUDE_FILTER = f -> f.charAt(0) != '-';\n    private static final Predicate<String> EXCLUDE_FILTER = INCLUDE_FILTER.negate();\n\n    protected final RestRequest request;\n    private final boolean detailedErrorsEnabled;\n    private final String format;\n    private final String filterPath;\n    private final boolean pretty;\n    private final boolean human;\n    private final String acceptHeader;\n\n    private BytesStream bytesOut;\n\n    /**\n     * Construct a channel for handling the request.\n     *\n     * @param request               the request\n     * @param detailedErrorsEnabled if detailed errors should be reported to the channel\n     * @throws IllegalArgumentException if parsing the pretty or human parameters fails\n     */\n    protected AbstractRestChannel(RestRequest request, boolean detailedErrorsEnabled) {\n        this.request = request;\n        this.detailedErrorsEnabled = detailedErrorsEnabled;\n        this.format = request.param(\"format\");\n        this.acceptHeader = request.header(\"Accept\");\n        this.filterPath = request.param(\"filter_path\", null);\n        this.pretty = request.paramAsBoolean(\"pretty\", false);\n        this.human = request.paramAsBoolean(\"human\", false);\n    }\n\n    @Override\n    public XContentBuilder newBuilder() throws IOException {\n        return newBuilder(request.getXContentType(), true);\n    }\n\n    @Override\n    public XContentBuilder newErrorBuilder() throws IOException {\n        // release whatever output we already buffered and write error response to fresh buffer\n        releaseOutputBuffer();\n        // Disable filtering when building error responses\n        return newBuilder(request.getXContentType(), false);\n    }\n\n    /**\n     * Creates a new {@link XContentBuilder} for a response to be sent using this channel. The builder's type is determined by the following\n     * logic. If the request has a format parameter that will be used to attempt to map to an {@link XContentType}. If there is no format\n     * parameter, the HTTP Accept header is checked to see if it can be matched to a {@link XContentType}. If this first attempt to map\n     * fails, the request content type will be used if the value is not {@code null}; if the value is {@code null} the output format falls\n     * back to JSON.\n     */\n    @Override\n    public XContentBuilder newBuilder(@Nullable XContentType requestContentType, boolean useFiltering) throws IOException {\n        return newBuilder(requestContentType, null, useFiltering);\n    }\n\n    /**\n     * Creates a new {@link XContentBuilder} for a response to be sent using this channel. The builder's type can be sent as a parameter,\n     * through {@code responseContentType} or it can fallback to {@link #newBuilder(XContentType, boolean)} logic if the sent type value\n     * is {@code null}.\n     */\n    @Override\n    public XContentBuilder newBuilder(\n        @Nullable XContentType requestContentType,\n        @Nullable XContentType responseContentType,\n        boolean useFiltering\n    ) throws IOException {\n        return newBuilder(\n            requestContentType,\n            responseContentType,\n            useFiltering,\n            org.elasticsearch.common.io.Streams.flushOnCloseStream(bytesOutput())\n        );\n    }\n\n    /**\n     * Creates a new {@link XContentBuilder} for a response to be sent using this channel. The builder's type can be sent as a parameter,\n     * through {@code responseContentType} or it can fallback to {@link #newBuilder(XContentType, boolean)} logic if the sent type value\n     * is {@code null}.\n     */\n    @Override\n    public XContentBuilder newBuilder(\n        @Nullable XContentType requestContentType,\n        @Nullable XContentType responseContentType,\n        boolean useFiltering,\n        OutputStream outputStream\n    ) throws IOException {\n\n        if (responseContentType == null) {\n            if (Strings.hasText(format)) {\n                responseContentType = XContentType.fromFormat(format);\n            }\n            if (responseContentType == null && Strings.hasText(acceptHeader)) {\n                responseContentType = XContentType.fromMediaType(acceptHeader);\n            }\n        }\n        // try to determine the response content type from the media type or the format query string parameter, with the format parameter\n        // taking precedence over the Accept header\n        if (responseContentType == null) {\n            if (requestContentType != null) {\n                // if there was a parsed content-type for the incoming request use that since no format was specified using the query\n                // string parameter or the HTTP Accept header\n                responseContentType = requestContentType;\n            } else {\n                // default to JSON output when all else fails\n                responseContentType = XContentType.JSON;\n            }\n        }\n\n        Set<String> includes = Collections.emptySet();\n        Set<String> excludes = Collections.emptySet();\n        if (useFiltering) {\n            Set<String> filters = Strings.tokenizeByCommaToSet(filterPath);\n            includes = filters.stream().filter(INCLUDE_FILTER).collect(toSet());\n            excludes = filters.stream().filter(EXCLUDE_FILTER).map(f -> f.substring(1)).collect(toSet());\n        }\n\n        Map<String, String> parameters = request.getParsedAccept() != null\n            ? request.getParsedAccept().getParameters()\n            : Collections.emptyMap();\n        ParsedMediaType responseMediaType = ParsedMediaType.parseMediaType(responseContentType, parameters);\n\n        XContentBuilder builder = new XContentBuilder(\n            XContentFactory.xContent(responseContentType),\n            outputStream,\n            includes,\n            excludes,\n            responseMediaType,\n            request.getRestApiVersion()\n        );\n        if (pretty) {\n            builder.prettyPrint().lfAtEnd();\n        }\n\n        builder.humanReadable(human);\n        return builder;\n    }\n\n    /**\n     * A channel level bytes output that can be reused. The bytes output is lazily instantiated\n     * by a call to {@link #newBytesOutput()}. This method should only be called once per request.\n     */\n    @Override\n    public final BytesStream bytesOutput() {\n        if (bytesOut != null) {\n            // fallback in case of encountering a bug, release the existing buffer if any (to avoid leaking memory) and acquire a new one\n            // to send out an error response\n            assert false : \"getting here is always a bug\";\n            logger.error(\"channel handling [{}] reused\", request.rawPath());\n            releaseOutputBuffer();\n        }\n        bytesOut = newBytesOutput();\n        return bytesOut;\n    }\n\n    @Override\n    public final void releaseOutputBuffer() {\n        if (bytesOut != null) {\n            try {\n                bytesOut.close();\n            } catch (IOException e) {\n                // should never throw\n                assert false : e;\n                throw new UncheckedIOException(e);\n            }\n            bytesOut = null;\n        }\n    }\n\n    protected BytesStream newBytesOutput() {\n        return new BytesStreamOutput();\n    }\n\n    @Override\n    public RestRequest request() {\n        return this.request;\n    }\n\n    @Override\n    public boolean detailedErrorsEnabled() {\n        return detailedErrorsEnabled;\n    }\n}\n",
  "file_path": "./codebase_small/server/src/main/java/org/elasticsearch/rest/AbstractRestChannel.java"
}