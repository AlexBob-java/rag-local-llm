[
  {
    "name": "ChunkedZipResponse",
    "type": "plain_text",
    "content": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.rest;\n\nimport org.apache.lucene.store.AlreadyClosedException;\nimport org.apache.lucene.util.BytesRef;\nimport org.elasticsearch.action.ActionListener;\nimport org.elasticsearch.action.support.SubscribableListener;\nimport org.elasticsearch.common.Strings;\nimport org.elasticsearch.common.bytes.BytesArray;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.collect.Iterators;\nimport org.elasticsearch.common.io.stream.BytesStream;\nimport org.elasticsearch.common.io.stream.RecyclerBytesStreamOutput;\nimport org.elasticsearch.common.recycler.Recycler;\nimport org.elasticsearch.core.AbstractRefCounted;\nimport org.elasticsearch.core.IOUtils;\nimport org.elasticsearch.core.Nullable;\nimport org.elasticsearch.core.RefCounted;\nimport org.elasticsearch.core.Releasable;\nimport org.elasticsearch.core.Releasables;\nimport org.elasticsearch.transport.Transports;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Queue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\n/**\n * A REST response with {@code Content-type: application/zip} to which the caller can write entries in an asynchronous and streaming\n * fashion.\n * <p>\n * Callers obtain a listener for individual entries using {@link #newEntryListener} and complete these listeners to submit the corresponding\n * entries for transmission. Internally, the output entries are held in a queue in the order in which the entry listeners are completed.\n * If the queue becomes empty then the response transmission is paused until the next entry becomes available.\n * <p>\n * The internal queue is unbounded. It is the caller's responsibility to ensure that the response does not consume an excess of resources\n * while it's being sent.\n * <p>\n * The caller must eventually call {@link ChunkedZipResponse#close} to finish the transmission of the response.\n * <p>\n * Note that individual entries can also pause themselves mid-transmission, since listeners returned by {@link #newEntryListener} accept a\n * pauseable {@link ChunkedRestResponseBodyPart}. Zip files do not have any mechanism which supports the multiplexing of outputs, so if the\n * entry at the head of the queue is paused then that will hold up the transmission of all subsequent entries too.\n */\npublic final class ChunkedZipResponse implements Releasable {\n\n    public static final String ZIP_CONTENT_TYPE = \"application/zip\";\n\n    /**\n     * The underlying stream that collects the raw bytes to be transmitted. Mutable, because we collect the contents of each chunk in a\n     * distinct stream that is held in this field while that chunk is under construction.\n     */\n    @Nullable // if there's no chunk under construction\n    private BytesStream targetStream;\n\n    private final ZipOutputStream zipOutputStream = new ZipOutputStream(new OutputStream() {\n        @Override\n        public void write(int b) throws IOException {\n            assert targetStream != null;\n            targetStream.write(b);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            assert targetStream != null;\n            targetStream.write(b, off, len);\n        }\n    }, StandardCharsets.UTF_8);\n\n    private final String filename;\n    private final RestChannel restChannel;\n\n    /**\n     * A listener for the first part (i.e. sequence of chunks of zipped data) of the next entry to become available for transmission after a\n     * pause. Completed with the newly-created unique active {@link AvailableChunksZipResponseBodyPart} within {@link #enqueueEntry}, and\n     * subscribed to via {@link AvailableChunksZipResponseBodyPart#getNextPart} when the current {@link AvailableChunksZipResponseBodyPart}\n     * becomes inactive because of a transmission pause.\n     */\n    @Nullable // if the first part hasn't been sent yet\n    private SubscribableListener<ChunkedRestResponseBodyPart> nextAvailableChunksListener;\n\n    /**\n     * A resource to be released when the transmission of the current entry is complete. Note that we may complete the transmission of\n     * multiple entries at the same time, if they are all processed by one call to {@link AvailableChunksZipResponseBodyPart#encodeChunk}\n     * and transmitted together.\n     */\n    @Nullable // if not currently sending an entry\n    private Releasable currentEntryReleasable;\n\n    /**\n     * @param filename     The name of the zip file, which appears in the {@code Content-Disposition} HTTP header of the response, and also\n     *                     is used as a directory prefix for all entries.\n     * @param restChannel  The {@link RestChannel} on which to send the response.\n     * @param onCompletion A resource which is released when the transmission is complete.\n     */\n    public ChunkedZipResponse(String filename, RestChannel restChannel, Releasable onCompletion) {\n        this.filename = filename;\n        this.restChannel = restChannel;\n        this.listenersRefs = AbstractRefCounted.of(() -> enqueueEntry(null, NO_MORE_ENTRIES, onCompletion));\n        this.rootListenerRef = Releasables.releaseOnce(listenersRefs::decRef);\n    }\n\n    private final RefCounted listenersRefs;\n    private final Releasable rootListenerRef;\n\n    /**\n     * Close this {@link ChunkedZipResponse}. Once closed, when there are no more pending listeners the zip file footer is sent.\n     */\n    @Override\n    public void close() {\n        rootListenerRef.close();\n    }\n\n    /**\n     * Create a listener which, when completed, will write the result {@link ChunkedRestResponseBodyPart}, and any following parts, as an\n     * entry in the response stream with the given name. If the listener is completed successfully with {@code null}, or exceptionally, then\n     * no entry is sent. When all listeners created by this method have been completed, the zip file footer is sent.\n     * <p>\n     * This method may be called as long as this {@link ChunkedZipResponse} is not closed, or there is at least one other incomplete entry\n     * listener.\n     *\n     * @param entryName  The name of the entry in the response zip file.\n     * @param releasable A resource which is released when the entry has been completely processed, i.e. when\n     *                   <ul>\n     *                   <li>the sequence of {@link ChunkedRestResponseBodyPart} instances have been fully sent, or</li>\n     *                   <li>the listener was completed with {@code null}, or an exception, indicating that no entry is to be sent, or</li>\n     *                   <li>the overall response was cancelled before completion and all resources related to the partial transmission of\n     *                   this entry have been released.</li>\n     *                   </ul>\n     */\n    public ActionListener<ChunkedRestResponseBodyPart> newEntryListener(String entryName, Releasable releasable) {\n        if (listenersRefs.tryIncRef()) {\n            final var zipEntry = new ZipEntry(filename + \"/\" + entryName);\n            return ActionListener.assertOnce(ActionListener.releaseAfter(new ActionListener<>() {\n                @Override\n                public void onResponse(ChunkedRestResponseBodyPart chunkedRestResponseBodyPart) {\n                    if (chunkedRestResponseBodyPart == null) {\n                        Releasables.closeExpectNoException(releasable);\n                    } else {\n                        enqueueEntry(zipEntry, chunkedRestResponseBodyPart, releasable);\n                    }\n                }\n\n                @Override\n                public void onFailure(Exception e) {\n                    Releasables.closeExpectNoException(releasable);\n                }\n\n                @Override\n                public String toString() {\n                    return \"ZipEntry[\" + zipEntry.getName() + \"]\";\n                }\n            }, listenersRefs::decRef));\n        } else {\n            assert false : \"already closed\";\n            throw new AlreadyClosedException(\"response already closed\");\n        }\n    }\n\n    /**\n     * A zip file entry which is ready for transmission, to be stored in {@link #entryQueue}.\n     *\n     * @param zipEntry      The entry metadata, to be written in its header.\n     * @param firstBodyPart The first part of the entry body. Subsequent parts, if present, come from\n     *                      {@link ChunkedRestResponseBodyPart#getNextPart}.\n     * @param releasable    A resource to release when this entry has been fully transmitted, or is no longer required because the\n     *                      transmission was cancelled.\n     */\n    private record ChunkedZipEntry(ZipEntry zipEntry, ChunkedRestResponseBodyPart firstBodyPart, Releasable releasable) {}\n\n    /**\n     * Queue of entries that are ready for transmission.\n     */\n    private final Queue<ChunkedZipEntry> entryQueue = new LinkedBlockingQueue<>();\n\n    /**\n     * Upper bound on the number of entries in the queue, atomically modified to ensure there's only one thread processing queue entries at\n     * once.\n     */\n    private final AtomicInteger queueLength = new AtomicInteger();\n\n    /**\n     * Ref-counting for access to the queue, to avoid clearing the queue on abort concurrently with an entry being sent.\n     */\n    private final RefCounted queueRefs = AbstractRefCounted.of(this::drainQueue);\n\n    /**\n     * Flag to indicate if the request has been aborted, at which point we should stop enqueueing more entries and promptly clean up the\n     * ones being sent. It's safe to ignore this, but without it in theory a constant stream of calls to {@link #enqueueEntry} could prevent\n     * {@link #drainQueue} from running for arbitrarily long.\n     */\n    private final AtomicBoolean isRestResponseFinished = new AtomicBoolean();\n\n    private boolean tryAcquireQueueRef() {\n        return isRestResponseFinished.get() == false && queueRefs.tryIncRef();\n    }\n\n    /**\n     * Called when an entry is ready for its transmission to start. Adds the entry to {@link #entryQueue} and spawns a new\n     * {@link AvailableChunksZipResponseBodyPart} if none is currently active.\n     *\n     * @param zipEntry      The entry metadata.\n     * @param firstBodyPart The first part of the entry. Entries may comprise multiple parts, with transmission pauses in between.\n     * @param releasable    Released when the entry has been fully transmitted.\n     */\n    private void enqueueEntry(ZipEntry zipEntry, ChunkedRestResponseBodyPart firstBodyPart, Releasable releasable) {\n        if (tryAcquireQueueRef()) {\n            try {\n                entryQueue.add(new ChunkedZipEntry(zipEntry, firstBodyPart, releasable));\n                if (queueLength.getAndIncrement() == 0) {\n                    // There is no active AvailableChunksZipResponseBodyPart, but there is now an entry in the queue, so we must create a\n                    // AvailableChunksZipResponseBodyPart to process it (along with any other entries that are concurrently added to the\n                    // queue). It's safe to mutate releasable and continuationListener here because they are only otherwise accessed by an\n                    // active AvailableChunksZipResponseBodyPart (which does not exist) or when all queueRefs have been released (which they\n                    // have not here).\n                    final var nextEntry = entryQueue.poll();\n                    assert nextEntry != null;\n                    final var availableChunks = new AvailableChunksZipResponseBodyPart(nextEntry.zipEntry(), nextEntry.firstBodyPart());\n                    assert currentEntryReleasable == null;\n                    currentEntryReleasable = nextEntry.releasable();\n                    final var currentAvailableChunksListener = nextAvailableChunksListener;\n                    nextAvailableChunksListener = new SubscribableListener<>();\n                    if (currentAvailableChunksListener == null) {\n                        // We are not resuming after a pause, this is the first entry to be sent, so we start the response transmission.\n                        final var restResponse = RestResponse.chunked(RestStatus.OK, availableChunks, this::restResponseFinished);\n                        restResponse.addHeader(\"content-disposition\", Strings.format(\"attachment; filename=\\\"%s.zip\\\"\", filename));\n                        restChannel.sendResponse(restResponse);\n                    } else {\n                        // We are resuming transmission after a pause, so just carry on sending the response body.\n                        currentAvailableChunksListener.onResponse(availableChunks);\n                    }\n                }\n            } finally {\n                queueRefs.decRef();\n            }\n        } else {\n            Releasables.closeExpectNoException(releasable);\n        }\n    }\n\n    private void restResponseFinished() {\n        assert Transports.assertTransportThread();\n        if (isRestResponseFinished.compareAndSet(false, true)) {\n            queueRefs.decRef();\n        }\n    }\n\n    private void drainQueue() {\n        assert isRestResponseFinished.get();\n        assert queueRefs.hasReferences() == false;\n        final var taskCount = queueLength.get() + 1;\n        final var releasables = new ArrayList<Releasable>(taskCount);\n        try {\n            releasables.add(currentEntryReleasable);\n            currentEntryReleasable = null;\n            ChunkedZipEntry entry;\n            while ((entry = entryQueue.poll()) != null) {\n                releasables.add(entry.releasable());\n            }\n            assert entryQueue.isEmpty() : entryQueue.size(); // no concurrent adds\n            assert releasables.size() == taskCount || releasables.size() == taskCount - 1 : taskCount + \" vs \" + releasables.size();\n        } finally {\n            Releasables.closeExpectNoException(Releasables.wrap(releasables));\n        }\n    }\n\n    /**\n     * A {@link ChunkedRestResponseBodyPart} which will yield all currently-available chunks by consuming entries from {@link #entryQueue}.\n     * There is only ever at most one active instance of this class at any time, in the sense that one such instance becoming inactive\n     * <i>happens-before</i> the creation of the next instance. One of these parts may send chunks for more than one entry.\n     */\n    private final class AvailableChunksZipResponseBodyPart implements ChunkedRestResponseBodyPart {\n\n        /**\n         * The next {@link ZipEntry} header whose transmission to start.\n         */\n        @Nullable // if no entry is available, or we've already sent the header for the current entry and are now sending its body.\n        private ZipEntry zipEntry;\n\n        /**\n         * The body part which is currently being transmitted, or {@link #NO_MORE_ENTRIES} if we're transmitting the zip file footer.\n         */\n        private ChunkedRestResponseBodyPart bodyPart;\n\n        /**\n         * True when we have run out of compressed chunks ready for immediate transmission, so the response is paused, but we expect to send\n         * more data later.\n         */\n        private boolean isResponsePaused;\n\n        /**\n         * True when we have sent the zip file footer, or the response was cancelled.\n         */\n        private boolean isResponseComplete;\n\n        /**\n         * A listener which is created when there are no more available chunks, so transmission is paused, subscribed to in\n         * {@link #getNextPart}, and then completed with the next body part (sequence of zipped chunks, i.e. a new (unique) active\n         * {@link AvailableChunksZipResponseBodyPart}).\n         */\n        private SubscribableListener<ChunkedRestResponseBodyPart> getNextPartListener;\n\n        /**\n         * A cache for an empty list to be used to collect the {@code Releasable} instances to be released when the next chunk has been\n         * fully transmitted. It's a list because a call to {@link #encodeChunk} may yield a chunk that completes several entries, each of\n         * which has its own resources to release. We cache this value across chunks because most chunks won't release anything, so we can\n         * keep the empty list around for later to save on allocations.\n         */\n        private ArrayList<Releasable> nextReleasablesCache = new ArrayList<>();\n\n        AvailableChunksZipResponseBodyPart(ZipEntry zipEntry, ChunkedRestResponseBodyPart bodyPart) {\n            this.zipEntry = zipEntry;\n            this.bodyPart = bodyPart;\n        }\n\n        /**\n         * @return whether this part of the compressed response is complete\n         */\n        @Override\n        public boolean isPartComplete() {\n            return isResponsePaused || isResponseComplete;\n        }\n\n        @Override\n        public boolean isLastPart() {\n            return isResponseComplete;\n        }\n\n        @Override\n        public void getNextPart(ActionListener<ChunkedRestResponseBodyPart> listener) {\n            assert getNextPartListener != null;\n            getNextPartListener.addListener(listener);\n        }\n\n        /**\n         * Transfer {@link #currentEntryReleasable} into the supplied collection (i.e. add it to {@code releasables} and then clear\n         * {@link #currentEntryReleasable}). Called when the last chunk of the last part of the current entry is serialized, so that we can\n         * start serializing chunks of the next entry straight away whilst delaying the release of the current entry's resources until the\n         * transmission of the chunk that is currently under construction.\n         */\n        private void transferCurrentEntryReleasable(ArrayList<Releasable> releasables) {\n            assert queueRefs.hasReferences();\n\n            if (currentEntryReleasable == null) {\n                return;\n            }\n\n            if (releasables == nextReleasablesCache) {\n                // adding the first value, so we must line up a new cached value for the next caller\n                nextReleasablesCache = new ArrayList<>();\n            }\n\n            releasables.add(currentEntryReleasable);\n            currentEntryReleasable = null;\n        }\n\n        @Override\n        public ReleasableBytesReference encodeChunk(int sizeHint, Recycler<BytesRef> recycler) throws IOException {\n            assert Transports.isTransportThread(Thread.currentThread());\n\n            final ArrayList<Releasable> releasables = nextReleasablesCache;\n            assert releasables.isEmpty();\n            try {\n                if (tryAcquireQueueRef()) {\n                    try {\n                        assert queueLength.get() > 0;\n                        // This is the current unique active AvailableChunksZipResponseBodyPart (i.e. queueLength is strictly positive and\n                        // we hold a queueRef), so any concurrent calls to enqueueEntry() at this point will just add to the queue and won't\n                        // spawn a new AvailableChunksZipResponseBodyPart or mutate any fields.\n\n                        final RecyclerBytesStreamOutput chunkStream = new RecyclerBytesStreamOutput(recycler);\n                        assert targetStream == null;\n                        targetStream = chunkStream;\n\n                        do {\n                            writeNextBytes(sizeHint, recycler, releasables);\n                        } while (isResponseComplete == false && isResponsePaused == false && chunkStream.size() < sizeHint);\n\n                        assert (releasables == nextReleasablesCache) == releasables.isEmpty();\n                        assert nextReleasablesCache.isEmpty();\n\n                        final Releasable chunkStreamReleasable = () -> Releasables.closeExpectNoException(chunkStream);\n                        final var result = new ReleasableBytesReference(\n                            chunkStream.bytes(),\n                            releasables.isEmpty()\n                                ? chunkStreamReleasable\n                                : Releasables.wrap(Iterators.concat(Iterators.single(chunkStreamReleasable), releasables.iterator()))\n                        );\n\n                        targetStream = null;\n                        return result;\n                    } finally {\n                        queueRefs.decRef();\n                    }\n                } else {\n                    // request aborted, nothing more to send (queue is being cleared by queueRefs#closeInternal)\n                    isResponseComplete = true;\n                    return new ReleasableBytesReference(BytesArray.EMPTY, () -> {});\n                }\n            } catch (Exception e) {\n                logger.error(\"failure encoding chunk\", e);\n                throw e;\n            } finally {\n                if (targetStream != null) {\n                    assert false : \"failure encoding chunk\";\n                    IOUtils.closeWhileHandlingException(targetStream, Releasables.wrap(releasables));\n                    targetStream = null;\n                }\n            }\n        }\n\n        private void writeNextBytes(int sizeHint, Recycler<BytesRef> recycler, ArrayList<Releasable> releasables) throws IOException {\n            try {\n                if (bodyPart == NO_MORE_ENTRIES) {\n                    // When the last ref from listenersRefs is completed we enqueue a final sentinel entry to trigger the transmission of\n                    // the zip file footer, which happens here:\n                    finishResponse(releasables);\n                    return;\n                }\n\n                if (zipEntry != null) {\n                    // This is the start of a new entry, so write the entry header:\n                    zipOutputStream.putNextEntry(zipEntry);\n                    zipEntry = null;\n                }\n\n                // Write the next chunk of the current entry to the zip stream\n                if (bodyPart.isPartComplete() == false) {\n                    try (var innerChunk = bodyPart.encodeChunk(sizeHint, recycler)) {\n                        final var iterator = innerChunk.iterator();\n                        BytesRef bytesRef;\n                        while ((bytesRef = iterator.next()) != null) {\n                            zipOutputStream.write(bytesRef.bytes, bytesRef.offset, bytesRef.length);\n                        }\n                    }\n                }\n                if (bodyPart.isPartComplete()) {\n                    // Complete the current part: if the current entry is incomplete then set up a listener for its next part, otherwise\n                    // move on to the next available entry and start sending its content.\n                    finishCurrentPart(releasables);\n                }\n            } finally {\n                // Flush any buffered data (but not the compressor) to chunkStream so that its size is accurate.\n                zipOutputStream.flush();\n            }\n        }\n\n        private void finishCurrentPart(ArrayList<Releasable> releasables) throws IOException {\n            if (bodyPart.isLastPart()) {\n                zipOutputStream.closeEntry();\n                transferCurrentEntryReleasable(releasables);\n                final var newQueueLength = queueLength.decrementAndGet();\n                if (newQueueLength == 0) {\n                    // The current entry is complete, but the next entry isn't available yet, so we pause transmission. This means we are no\n                    // longer an active AvailableChunksZipResponseBodyPart, so any concurrent calls to enqueueEntry() at this point will now\n                    // spawn a new AvailableChunksZipResponseBodyPart to take our place.\n                    isResponsePaused = true;\n                    assert getNextPartListener == null;\n                    assert nextAvailableChunksListener != null;\n                    // Calling our getNextPart() will eventually yield the next body part supplied to enqueueEntry():\n                    getNextPartListener = nextAvailableChunksListener;\n                } else {\n                    // The current entry is complete, and the first part of the next entry is already available, so we start sending its\n                    // chunks too. This means we're still the unique active AvailableChunksZipResponseBodyPart. We re-use this\n                    // AvailableChunksZipResponseBodyPart instance rather than creating a new one to avoid unnecessary allocations.\n                    final var nextEntry = entryQueue.poll();\n                    assert nextEntry != null;\n                    zipEntry = nextEntry.zipEntry();\n                    bodyPart = nextEntry.firstBodyPart();\n                    currentEntryReleasable = nextEntry.releasable();\n                }\n            } else {\n                // The current entry has more parts to come, but we have reached the end of the current part, so we assume that the next\n                // part is not yet available and therefore must pause transmission. This means we are no longer an active\n                // AvailableChunksZipResponseBodyPart, but also another call to enqueueEntry() won't create a new\n                // AvailableChunksZipResponseBodyPart because the current entry is still counted in queueLength:\n                assert queueLength.get() > 0;\n                // Instead, we create a new active AvailableChunksZipResponseBodyPart when the next part of the current entry becomes\n                // available. It doesn't affect correctness if the next part is already available, it's just a little less efficient to make\n                // a new AvailableChunksZipResponseBodyPart in that case. That's ok, entries can coalesce all the available parts together\n                // themselves if efficiency really matters.\n                isResponsePaused = true;\n                assert getNextPartListener == null;\n                // Calling our getNextPart() will eventually yield the next body part from the current entry:\n                getNextPartListener = SubscribableListener.newForked(\n                    l -> bodyPart.getNextPart(l.map(p -> new AvailableChunksZipResponseBodyPart(null, p)))\n                );\n            }\n        }\n\n        private void finishResponse(ArrayList<Releasable> releasables) throws IOException {\n            assert zipEntry == null;\n            assert entryQueue.isEmpty() : entryQueue.size();\n            zipOutputStream.finish();\n            isResponseComplete = true;\n            transferCurrentEntryReleasable(releasables);\n            assert getNextPartListener == null;\n        }\n\n        @Override\n        public String getResponseContentTypeString() {\n            return ZIP_CONTENT_TYPE;\n        }\n    }\n\n    /**\n     * Sentinel body part indicating the end of the zip file.\n     */\n    private static final ChunkedRestResponseBodyPart NO_MORE_ENTRIES = new ChunkedRestResponseBodyPart() {\n        @Override\n        public boolean isPartComplete() {\n            assert false : \"never called\";\n            return true;\n        }\n\n        @Override\n        public boolean isLastPart() {\n            assert false : \"never called\";\n            return true;\n        }\n\n        @Override\n        public void getNextPart(ActionListener<ChunkedRestResponseBodyPart> listener) {\n            assert false : \"never called\";\n            listener.onFailure(new IllegalStateException(\"impossible\"));\n        }\n\n        @Override\n        public ReleasableBytesReference encodeChunk(int sizeHint, Recycler<BytesRef> recycler) {\n            assert false : \"never called\";\n            return ReleasableBytesReference.empty();\n        }\n\n        @Override\n        public String getResponseContentTypeString() {\n            assert false : \"never called\";\n            return ZIP_CONTENT_TYPE;\n        }\n    };\n}\n",
    "file_path": "./codebase_small/server/src/main/java/org/elasticsearch/rest/ChunkedZipResponse.java"
  }
]