{
  "name": "RestStatus",
  "type": "class_full",
  "content": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.rest;\n\nimport org.elasticsearch.action.ShardOperationFailedException;\nimport org.elasticsearch.common.io.stream.StreamInput;\nimport org.elasticsearch.common.io.stream.StreamOutput;\nimport org.elasticsearch.common.util.Maps;\n\nimport java.io.IOException;\nimport java.util.Map;\n\nimport static java.util.Collections.unmodifiableMap;\n\npublic enum RestStatus {\n\n    /**\n     * The client SHOULD continue with its request. This interim response is used to inform the client that the\n     * initial part of the request has been received and has not yet been rejected by the server. The client\n     * SHOULD continue by sending the remainder of the request or, if the request has already been completed,\n     * ignore this response. The server MUST send a final response after the request has been completed.\n     */\n    CONTINUE(100),\n\n    /**\n     * The server understands and is willing to comply with the client's request, via the Upgrade message header field\n     * (section 14.42), for a change in the application protocol being used on this connection. The server will\n     * switch protocols to those defined by the response's Upgrade header field immediately after the empty line\n     * which terminates the 101 response.\n     */\n    SWITCHING_PROTOCOLS(101),\n\n    /**\n     * The request has succeeded. The information returned with the response is dependent on the method\n     * used in the request, for example:\n     * <ul>\n     * <li>GET: an entity corresponding to the requested resource is sent in the response;</li>\n     * <li>HEAD: the entity-header fields corresponding to the requested resource are sent in the response without any message-body;</li>\n     * <li>POST: an entity describing or containing the result of the action;</li>\n     * <li>TRACE: an entity containing the request message as received by the end server.</li>\n     * </ul>\n     */\n    OK(200),\n\n    /**\n     * The request has been fulfilled and resulted in a new resource being created. The newly created resource can\n     * be referenced by the URI(s) returned in the entity of the response, with the most specific URI for the\n     * resource given by a Location header field. The response SHOULD include an entity containing a list of resource\n     * characteristics and location(s) from which the user or user agent can choose the one most appropriate. The\n     * entity format is specified by the media type given in the Content-Type header field. The origin server MUST\n     * create the resource before returning the 201 status code. If the action cannot be carried out immediately, the\n     * server SHOULD respond with 202 (Accepted) response instead.\n     * <p>\n     * A 201 response MAY contain an ETag response header field indicating the current value of the entity tag\n     * for the requested variant just created, see section 14.19.\n     */\n    CREATED(201),\n\n    /**\n     * The request has been accepted for processing, but the processing has not been completed.  The request might\n     * or might not eventually be acted upon, as it might be disallowed when processing actually takes place. There\n     * is no facility for re-sending a status code from an asynchronous operation such as this.\n     * <p>\n     * The 202 response is intentionally non-committal. Its purpose is to allow a server to accept a request for\n     * some other process (perhaps a batch-oriented process that is only run once per day) without requiring that\n     * the user agent's connection to the server persist until the process is completed. The entity returned with\n     * this response SHOULD include an indication of the request's current status and either a pointer to a status\n     * monitor or some estimate of when the user can expect the request to be fulfilled.\n     */\n    ACCEPTED(202),\n\n    /**\n     * The returned meta information in the entity-header is not the definitive set as available from the origin\n     * server, but is gathered from a local or a third-party copy. The set presented MAY be a subset or super set\n     * of the original version. For example, including local annotation information about the resource might\n     * result in a super set of the meta information known by the origin server. Use of this response code\n     * is not required and is only appropriate when the response would otherwise be 200 (OK).\n     */\n    NON_AUTHORITATIVE_INFORMATION(203),\n\n    /**\n     * The server has fulfilled the request but does not need to return an entity-body, and might want to return\n     * updated meta information. The response MAY include new or updated meta information in the form of\n     * entity-headers, which if present SHOULD be associated with the requested variant.\n     * <p>\n     * If the client is a user agent, it SHOULD NOT change its document view from that which caused the request\n     * to be sent. This response is primarily intended to allow input for actions to take place without causing a\n     * change to the user agent's active document view, although any new or updated meta information SHOULD be\n     * applied to the document currently in the user agent's active view.\n     * <p>\n     * The 204 response MUST NOT include a message-body, and thus is always terminated by the first empty\n     * line after the header fields.\n     */\n    NO_CONTENT(204),\n\n    /**\n     * The server has fulfilled the request and the user agent SHOULD reset the document view which caused the\n     * request to be sent. This response is primarily intended to allow input for actions to take place via user\n     * input, followed by a clearing of the form in which the input is given so that the user can easily initiate\n     * another input action. The response MUST NOT include an entity.\n     */\n    RESET_CONTENT(205),\n\n    /**\n     * The server has fulfilled the partial GET request for the resource. The request MUST have included a Range\n     * header field (section 14.35) indicating the desired range, and MAY have included an If-Range header\n     * field (section 14.27) to make the request conditional.\n     * <p>\n     * The response MUST include the following header fields:\n     * <ul>\n     * <li>Either a Content-Range header field (section 14.16) indicating the range included with this response,\n     * or a multipart/byteranges Content-Type including Content-Range fields for each part. If a Content-Length\n     * header field is present in the response, its value MUST match the actual number of OCTETs transmitted in\n     * the message-body.</li>\n     * <li>Date</li>\n     * <li>ETag and/or Content-Location, if the header would have been sent in a 200 response to the same request</li>\n     * <li>Expires, Cache-Control, and/or Vary, if the field-value might differ from that sent in any previous\n     * response for the same variant</li>\n     * </ul>\n     * <p>\n     * If the 206 response is the result of an If-Range request that used a strong cache validator\n     * (see section 13.3.3), the response SHOULD NOT include other entity-headers. If the response is the result\n     * of an If-Range request that used a weak validator, the response MUST NOT include other entity-headers;\n     * this prevents inconsistencies between cached entity-bodies and updated headers. Otherwise, the response MUST\n     * include all of the entity-headers that would have been returned with a 200 (OK) response to the same request.\n     * <p>\n     * A cache MUST NOT combine a 206 response with other previously cached content if the ETag or Last-Modified\n     * headers do not match exactly, see 13.5.4.\n     * <p>\n     * A cache that does not support the Range and Content-Range headers MUST NOT cache 206 (Partial) responses.\n     */\n    PARTIAL_CONTENT(206),\n\n    /**\n     * The 207 (Multi-Status) status code provides status for multiple independent operations (see Section 13 for\n     * more information).\n     * <p>\n     * A Multi-Status response conveys information about multiple resources in situations where multiple status\n     * codes might be appropriate. The default Multi-Status response body is a text/xml or application/xml HTTP\n     * entity with a 'multistatus' root element. Further elements contain 200, 300, 400, and 500 series status codes\n     * generated during the method invocation. 100 series status codes SHOULD NOT be recorded in a 'response'\n     * XML element.\n     * <p>\n     * Although '207' is used as the overall response status code, the recipient needs to consult the contents\n     * of the multistatus response body for further information about the success or failure of the method execution.\n     * The response MAY be used in success, partial success and also in failure situations.\n     * <p>\n     * The 'multistatus' root element holds zero or more 'response' elements in any order, each with\n     * information about an individual resource. Each 'response' element MUST have an 'href' element\n     * to identify the resource.\n     */\n    MULTI_STATUS(207),\n\n    /**\n     * The requested resource corresponds to any one of a set of representations, each with its own specific\n     * location, and agent-driven negotiation information (section 12) is being provided so that the user (or user\n     * agent) can select a preferred representation and redirect its request to that location.\n     * <p>\n     * Unless it was a HEAD request, the response SHOULD include an entity containing a list of resource\n     * characteristics and location(s) from which the user or user agent can choose the one most appropriate.\n     * The entity format is specified by the media type given in the Content-Type header field. Depending upon the\n     * format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed\n     * automatically. However, this specification does not define any standard for such automatic selection.\n     * <p>\n     * If the server has a preferred choice of representation, it SHOULD include the specific URI for that\n     * representation in the Location field; user agents MAY use the Location field value for automatic redirection.\n     * This response is cacheable unless indicated otherwise.\n     */\n    MULTIPLE_CHOICES(300),\n\n    /**\n     * The requested resource has been assigned a new permanent URI and any future references to this resource\n     * SHOULD use one of the returned URIs.  Clients with link editing capabilities ought to automatically re-link\n     * references to the Request-URI to one or more of the new references returned by the server, where possible.\n     * This response is cacheable unless indicated otherwise.\n     * <p>\n     * The new permanent URI SHOULD be given by the Location field in the response. Unless the request method\n     * was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).\n     * <p>\n     * If the 301 status code is received in response to a request other than GET or HEAD, the user agent\n     * MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change\n     * the conditions under which the request was issued.\n     */\n    MOVED_PERMANENTLY(301),\n\n    /**\n     * The requested resource resides temporarily under a different URI. Since the redirection might be altered on\n     * occasion, the client SHOULD continue to use the Request-URI for future requests.  This response is only\n     * cacheable if indicated by a Cache-Control or Expires header field.\n     * <p>\n     * The temporary URI SHOULD be given by the Location field in the response. Unless the request method was\n     * HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).\n     * <p>\n     * If the 302 status code is received in response to a request other than GET or HEAD, the user agent\n     * MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change\n     * the conditions under which the request was issued.\n     */\n    FOUND(302),\n\n    /**\n     * The response to the request can be found under a different URI and SHOULD be retrieved using a GET method on\n     * that resource. This method exists primarily to allow the output of a POST-activated script to redirect the\n     * user agent to a selected resource. The new URI is not a substitute reference for the originally requested\n     * resource. The 303 response MUST NOT be cached, but the response to the second (redirected) request might be\n     * cacheable.\n     * <p>\n     * The different URI SHOULD be given by the Location field in the response. Unless the request method was\n     * HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).\n     */\n    SEE_OTHER(303),\n\n    /**\n     * If the client has performed a conditional GET request and access is allowed, but the document has not been\n     * modified, the server SHOULD respond with this status code. The 304 response MUST NOT contain a message-body,\n     * and thus is always terminated by the first empty line after the header fields.\n     * <p>\n     * The response MUST include the following header fields:\n     * <ul>\n     * <li>Date, unless its omission is required by section 14.18.1\n     * If a clockless origin server obeys these rules, and proxies and clients add their own Date to any\n     * response received without one (as already specified by [RFC 2068], section 14.19), caches will operate\n     * correctly.\n     * </li>\n     * <li>ETag and/or Content-Location, if the header would have been sent in a 200 response to the same request</li>\n     * <li>Expires, Cache-Control, and/or Vary, if the field-value might differ from that sent in any previous\n     * response for the same variant</li>\n     * </ul>\n     * <p>\n     * If the conditional GET used a strong cache validator (see section 13.3.3), the response SHOULD NOT include\n     * other entity-headers. Otherwise (i.e., the conditional GET used a weak validator), the response MUST NOT\n     * include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers.\n     * <p>\n     * If a 304 response indicates an entity not currently cached, then the cache MUST disregard the response\n     * and repeat the request without the conditional.\n     * <p>\n     * If a cache uses a received 304 response to update a cache entry, the cache MUST update the entry to\n     * reflect any new field values given in the response.\n     */\n    NOT_MODIFIED(304),\n\n    /**\n     * The requested resource MUST be accessed through the proxy given by the Location field. The Location field\n     * gives the URI of the proxy. The recipient is expected to repeat this single request via the proxy.\n     * 305 responses MUST only be generated by origin servers.\n     */\n    USE_PROXY(305),\n\n    /**\n     * The requested resource resides temporarily under a different URI. Since the redirection MAY be altered on\n     * occasion, the client SHOULD continue to use the Request-URI for future requests.  This response is only\n     * cacheable if indicated by a Cache-Control or Expires header field.\n     * <p>\n     * The temporary URI SHOULD be given by the Location field in the response. Unless the request method was\n     * HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s) ,\n     * since many pre-HTTP/1.1 user agents do not understand the 307 status. Therefore, the note SHOULD contain\n     * the information necessary for a user to repeat the original request on the new URI.\n     * <p>\n     * If the 307 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT\n     * automatically redirect the request unless it can be confirmed by the user, since this might change the\n     * conditions under which the request was issued.\n     */\n    TEMPORARY_REDIRECT(307),\n\n    /**\n     * The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the\n     * request without modifications.\n     */\n    BAD_REQUEST(400),\n\n    /**\n     * The request requires user authentication. The response MUST include a WWW-Authenticate header field\n     * (section 14.47) containing a challenge applicable to the requested resource. The client MAY repeat the request\n     * with a suitable Authorization header field (section 14.8). If the request already included Authorization\n     * credentials, then the 401 response indicates that authorization has been refused for those credentials.\n     * If the 401 response contains the same challenge as the prior response, and the user agent has already attempted\n     * authentication at least once, then the user SHOULD be presented the entity that was given in the response,\n     * since that entity might include relevant diagnostic information. HTTP access authentication is explained in\n     * \"HTTP Authentication: Basic and Digest Access Authentication\" [43].\n     */\n    UNAUTHORIZED(401),\n\n    /**\n     * This code is reserved for future use.\n     */\n    PAYMENT_REQUIRED(402),\n\n    /**\n     * The server understood the request, but is refusing to fulfill it. Authorization will not help and the request\n     * SHOULD NOT be repeated. If the request method was not HEAD and the server wishes to make public why the\n     * request has not been fulfilled, it SHOULD describe the reason for the refusal in the entity.  If the server\n     * does not wish to make this information available to the client, the status code 404 (Not Found) can be used\n     * instead.\n     */\n    FORBIDDEN(403),\n\n    /**\n     * The server has not found anything matching the Request-URI. No indication is given of whether the condition\n     * is temporary or permanent. The 410 (Gone) status code SHOULD be used if the server knows, through some\n     * internally configurable mechanism, that an old resource is permanently unavailable and has no forwarding\n     * address. This status code is commonly used when the server does not wish to reveal exactly why the request\n     * has been refused, or when no other response is applicable.\n     */\n    NOT_FOUND(404),\n\n    /**\n     * The method specified in the Request-Line is not allowed for the resource identified by the Request-URI.\n     * The response MUST include an Allow header containing a list of valid methods for the requested resource.\n     */\n    METHOD_NOT_ALLOWED(405),\n\n    /**\n     * The resource identified by the request is only capable of generating response entities which have content\n     * characteristics not acceptable according to the accept headers sent in the request.\n     * <p>\n     * Unless it was a HEAD request, the response SHOULD include an entity containing a list of available entity\n     * characteristics and location(s) from which the user or user agent can choose the one most appropriate.\n     * The entity format is specified by the media type given in the Content-Type header field. Depending upon the\n     * format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed\n     * automatically. However, this specification does not define any standard for such automatic selection.\n     * <p>\n     * Note: HTTP/1.1 servers are allowed to return responses which are not acceptable according to the accept\n     * headers sent in the request. In some cases, this may even be preferable to sending a 406 response. User\n     * agents are encouraged to inspect the headers of an incoming response to determine if it is acceptable.\n     * <p>\n     * If the response could be unacceptable, a user agent SHOULD temporarily stop receipt of more data and query\n     * the user for a decision on further actions.\n     */\n    NOT_ACCEPTABLE(406),\n\n    /**\n     * This code is similar to 401 (Unauthorized), but indicates that the client must first authenticate itself with\n     * the proxy. The proxy MUST return a Proxy-Authenticate header field (section 14.33) containing a challenge\n     * applicable to the proxy for the requested resource. The client MAY repeat the request with a suitable\n     * Proxy-Authorization header field (section 14.34). HTTP access authentication is explained in\n     * \"HTTP Authentication: Basic and Digest Access Authentication\" [43].\n     */\n    PROXY_AUTHENTICATION(407),\n\n    /**\n     * The client did not produce a request within the time that the server was prepared to wait. The client MAY\n     * repeat the request without modifications at any later time.\n     */\n    REQUEST_TIMEOUT(408),\n\n    /**\n     * The request could not be completed due to a conflict with the current state of the resource. This code is\n     * only allowed in situations where it is expected that the user might be able to resolve the conflict and\n     * resubmit the request. The response body SHOULD include enough information for the user to recognize the\n     * source of the conflict. Ideally, the response entity would include enough information for the user or user\n     * agent to fix the problem; however, that might not be possible and is not required.\n     * <p>\n     * Conflicts are most likely to occur in response to a PUT request. For example, if versioning were being\n     * used and the entity being PUT included changes to a resource which conflict with those made by an earlier\n     * (third-party) request, the server might use the 409 response to indicate that it can't complete the request.\n     * In this case, the response entity would likely contain a list of the differences between the two versions in\n     * a format defined by the response Content-Type.\n     */\n    CONFLICT(409),\n\n    /**\n     * The requested resource is no longer available at the server and no forwarding address is known. This condition\n     * is expected to be considered permanent. Clients with link editing capabilities SHOULD delete references to\n     * the Request-URI after user approval. If the server does not know, or has no facility to determine, whether or\n     * not the condition is permanent, the status code 404 (Not Found) SHOULD be used instead. This response is\n     * cacheable unless indicated otherwise.\n     * <p>\n     * The 410 response is primarily intended to assist the task of web maintenance by notifying the recipient\n     * that the resource is intentionally unavailable and that the server owners desire that remote links to that\n     * resource be removed. Such an event is common for limited-time, promotional services and for resources belonging\n     * to individuals no longer working at the server's site. It is not necessary to mark all permanently unavailable\n     * resources as \"gone\" or to keep the mark for any length of time -- that is left to the discretion of the server\n     * owner.\n     */\n    GONE(410),\n\n    /**\n     * The server refuses to accept the request without a defined Content-Length. The client MAY repeat the request\n     * if it adds a valid Content-Length header field containing the length of the message-body in the request message.\n     */\n    LENGTH_REQUIRED(411),\n\n    /**\n     * The precondition given in one or more of the request-header fields evaluated to false when it was tested on\n     * the server. This response code allows the client to place preconditions on the current resource metainformation\n     * (header field data) and thus prevent the requested method from being applied to a resource other than the one\n     * intended.\n     */\n    PRECONDITION_FAILED(412),\n\n    /**\n     * The server is refusing to process a request because the request entity is larger than the server is willing\n     * or able to process. The server MAY close the connection to prevent the client from continuing the request.\n     * <p>\n     * If the condition is temporary, the server SHOULD include a Retry-After header field to indicate that it\n     * is temporary and after what time the client MAY try again.\n     */\n    REQUEST_ENTITY_TOO_LARGE(413),\n\n    /**\n     * The server is refusing to service the request because the Request-URI is longer than the server is willing\n     * to interpret. This rare condition is only likely to occur when a client has improperly converted a POST\n     * request to a GET request with long query information, when the client has descended into a URI \"black hole\"\n     * of redirection (e.g., a redirected URI prefix that points to a suffix of itself), or when the server is\n     * under attack by a client attempting to exploit security holes present in some servers using fixed-length\n     * buffers for reading or manipulating the Request-URI.\n     */\n    REQUEST_URI_TOO_LONG(414),\n\n    /**\n     * The server is refusing to service the request because the entity of the request is in a format not supported\n     * by the requested resource for the requested method.\n     */\n    UNSUPPORTED_MEDIA_TYPE(415),\n\n    /**\n     * A server SHOULD return a response with this status code if a request included a Range request-header field\n     * (section 14.35), and none of the range-specifier values in this field overlap the current extent of the\n     * selected resource, and the request did not include an If-Range request-header field. (For byte-ranges, this\n     * means that the first-byte-pos of all of the byte-range-spec values were greater than the current length of\n     * the selected resource.)\n     * <p>\n     * When this status code is returned for a byte-range request, the response SHOULD include a Content-Range\n     * entity-header field specifying the current length of the selected resource (see section 14.16). This\n     * response MUST NOT use the multipart/byteranges content-type.\n     */\n    REQUESTED_RANGE_NOT_SATISFIED(416),\n\n    /**\n     * The expectation given in an Expect request-header field (see section 14.20) could not be met by this server,\n     * or, if the server is a proxy, the server has unambiguous evidence that the request could not be met by the\n     * next-hop server.\n     */\n    EXPECTATION_FAILED(417),\n\n    /**\n     * The 422 (Unprocessable Entity) status code means the server understands the content type of the request\n     * entity (hence a 415(Unsupported Media Type) status code is inappropriate), and the syntax of the request\n     * entity is correct (thus a 400 (Bad Request) status code is inappropriate) but was unable to process the\n     * contained instructions. For example, this error condition may occur if an XML request body contains\n     * well-formed (i.e., syntactically correct), but semantically erroneous, XML instructions.\n     */\n    UNPROCESSABLE_ENTITY(422),\n\n    /**\n     * The 423 (Locked) status code means the source or destination resource of a method is locked. This response\n     * SHOULD contain an appropriate precondition or postcondition code, such as 'lock-token-submitted' or\n     * 'no-conflicting-lock'.\n     */\n    LOCKED(423),\n\n    /**\n     * The 424 (Failed Dependency) status code means that the method could not be performed on the resource because\n     * the requested action depended on another action and that action failed. For example, if a command in a\n     * PROPPATCH method fails, then, at minimum, the rest of the commands will also fail with 424 (Failed Dependency).\n     */\n    FAILED_DEPENDENCY(424),\n\n    /**\n     * 429 Too Many Requests (RFC6585)\n     */\n    TOO_MANY_REQUESTS(429),\n\n    /**\n     * The server encountered an unexpected condition which prevented it from fulfilling the request.\n     */\n    INTERNAL_SERVER_ERROR(500),\n\n    /**\n     * The server does not support the functionality required to fulfill the request. This is the appropriate\n     * response when the server does not recognize the request method and is not capable of supporting it for any\n     * resource.\n     */\n    NOT_IMPLEMENTED(501),\n\n    /**\n     * The server, while acting as a gateway or proxy, received an invalid response from the upstream server it\n     * accessed in attempting to fulfill the request.\n     */\n    BAD_GATEWAY(502),\n\n    /**\n     * The server is currently unable to handle the request due to a temporary overloading or maintenance of the\n     * server. The implication is that this is a temporary condition which will be alleviated after some delay.\n     * If known, the length of the delay MAY be indicated in a Retry-After header. If no Retry-After is given,\n     * the client SHOULD handle the response as it would for a 500 response.\n     */\n    SERVICE_UNAVAILABLE(503),\n\n    /**\n     * The server, while acting as a gateway or proxy, did not receive a timely response from the upstream server\n     * specified by the URI (e.g. HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed to access\n     * in attempting to complete the request.\n     */\n    GATEWAY_TIMEOUT(504),\n\n    /**\n     * The server does not support, or refuses to support, the HTTP protocol version that was used in the request\n     * message. The server is indicating that it is unable or unwilling to complete the request using the same major\n     * version as the client, as described in section 3.1, other than with this error message. The response SHOULD\n     * contain an entity describing why that version is not supported and what other protocols are supported by\n     * that server.\n     */\n    HTTP_VERSION_NOT_SUPPORTED(505),\n\n    /**\n     * The 507 (Insufficient Storage) status code means the method could not be performed on the resource because\n     * the server is unable to store the representation needed to successfully complete the request. This condition\n     * is considered to be temporary. If the request that received this status code was the result of a user action,\n     * the request MUST NOT be repeated until it is requested by a separate user action.\n     */\n    INSUFFICIENT_STORAGE(507);\n\n    private static final Map<Integer, RestStatus> CODE_TO_STATUS;\n    static {\n        RestStatus[] values = values();\n        Map<Integer, RestStatus> codeToStatus = Maps.newMapWithExpectedSize(values.length);\n        for (RestStatus value : values) {\n            codeToStatus.put(value.status, value);\n        }\n        CODE_TO_STATUS = unmodifiableMap(codeToStatus);\n    }\n\n    private int status;\n\n    RestStatus(int status) {\n        this.status = (short) status;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public static RestStatus readFrom(StreamInput in) throws IOException {\n        return RestStatus.valueOf(in.readString());\n    }\n\n    public static void writeTo(StreamOutput out, RestStatus status) throws IOException {\n        out.writeString(status.name());\n    }\n\n    public static RestStatus status(int successfulShards, int totalShards, ShardOperationFailedException... failures) {\n        if (failures.length == 0) {\n            if (successfulShards == 0 && totalShards > 0) {\n                return RestStatus.SERVICE_UNAVAILABLE;\n            }\n            return RestStatus.OK;\n        }\n        RestStatus status = RestStatus.OK;\n        if (successfulShards == 0 && totalShards > 0) {\n            for (ShardOperationFailedException failure : failures) {\n                RestStatus shardStatus = failure.status();\n                if (shardStatus.getStatus() >= status.getStatus()) {\n                    status = failure.status();\n                }\n            }\n            return status;\n        }\n        return status;\n    }\n\n    /**\n     * Turn a status code into a {@link RestStatus}, returning null if we don't know that status.\n     */\n    public static RestStatus fromCode(int code) {\n        return CODE_TO_STATUS.get(code);\n    }\n\n    /**\n     * Utility method to determine if an HTTP status code is \"Successful\"\n     *\n     * as defined by <a href=\"https://datatracker.ietf.org/doc/html/rfc9110#section-15.3\">RFC 9110</a>\n     *\n     * @param code An HTTP status code\n     * @return true if it is a 2xx code, false otherwise\n     */\n    public static boolean isSuccessful(int code) {\n        return code >= 200 && code < 300;\n    }\n}\n",
  "file_path": "./codebase_small/server/src/main/java/org/elasticsearch/rest/RestStatus.java"
}