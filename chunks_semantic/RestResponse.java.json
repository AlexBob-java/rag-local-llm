[
  {
    "name": "RestResponse",
    "type": "plain_text",
    "content": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.rest;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.util.Supplier;\nimport org.elasticsearch.ElasticsearchException;\nimport org.elasticsearch.ExceptionsHelper;\nimport org.elasticsearch.common.bytes.BytesArray;\nimport org.elasticsearch.common.bytes.BytesReference;\nimport org.elasticsearch.common.logging.DeprecationCategory;\nimport org.elasticsearch.common.logging.DeprecationLogger;\nimport org.elasticsearch.common.util.Maps;\nimport org.elasticsearch.core.Nullable;\nimport org.elasticsearch.core.Releasable;\nimport org.elasticsearch.core.Releasables;\nimport org.elasticsearch.core.RestApiVersion;\nimport org.elasticsearch.xcontent.ToXContent;\nimport org.elasticsearch.xcontent.XContentBuilder;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport static java.util.Collections.singletonMap;\nimport static org.elasticsearch.ElasticsearchException.REST_EXCEPTION_SKIP_STACK_TRACE;\nimport static org.elasticsearch.rest.RestController.ELASTIC_PRODUCT_HTTP_HEADER;\nimport static org.elasticsearch.rest.RestController.ERROR_TRACE_DEFAULT;\n\npublic final class RestResponse implements Releasable {\n\n    public static final String TEXT_CONTENT_TYPE = \"text/plain; charset=UTF-8\";\n    public static final Set<String> RESPONSE_PARAMS = Set.of(\"error_trace\");\n\n    static final String STATUS = \"status\";\n\n    private static final Logger SUPPRESSED_ERROR_LOGGER = LogManager.getLogger(\"rest.suppressed\");\n    private static final DeprecationLogger deprecationLogger = DeprecationLogger.getLogger(AbstractRestChannel.class);\n\n    private final RestStatus status;\n\n    @Nullable\n    private final BytesReference content;\n\n    @Nullable\n    private final ChunkedRestResponseBodyPart chunkedResponseBody;\n    private final String responseMediaType;\n    private Map<String, List<String>> customHeaders;\n\n    @Nullable\n    private final Releasable releasable;\n\n    /**\n     * Creates a new response based on {@link XContentBuilder}.\n     */\n    public RestResponse(RestStatus status, XContentBuilder builder) {\n        this(status, builder.getResponseContentTypeString(), BytesReference.bytes(builder));\n    }\n\n    /**\n     * Creates a new plain text response.\n     */\n    public RestResponse(RestStatus status, String content) {\n        this(status, TEXT_CONTENT_TYPE, new BytesArray(content));\n    }\n\n    /**\n     * Creates a new plain text response.\n     */\n    public RestResponse(RestStatus status, String responseMediaType, String content) {\n        this(status, responseMediaType, new BytesArray(content));\n    }\n\n    public RestResponse(RestStatus status, String responseMediaType, BytesReference content) {\n        this(status, responseMediaType, content, null, null);\n    }\n\n    private RestResponse(RestStatus status, String responseMediaType, BytesReference content, @Nullable Releasable releasable) {\n        this(status, responseMediaType, content, null, releasable);\n    }\n\n    public static RestResponse chunked(RestStatus restStatus, ChunkedRestResponseBodyPart content, @Nullable Releasable releasable) {\n        if (content.isPartComplete()) {\n            assert content.isLastPart() : \"response with continuations must have at least one (possibly-empty) chunk in each part\";\n            return new RestResponse(restStatus, content.getResponseContentTypeString(), BytesArray.EMPTY, releasable);\n        } else {\n            return new RestResponse(restStatus, content.getResponseContentTypeString(), null, content, releasable);\n        }\n    }\n\n    /**\n     * Creates a binary response.\n     */\n    private RestResponse(\n        RestStatus status,\n        String responseMediaType,\n        @Nullable BytesReference content,\n        @Nullable ChunkedRestResponseBodyPart chunkedResponseBody,\n        @Nullable Releasable releasable\n    ) {\n        this.status = status;\n        this.content = content;\n        this.responseMediaType = responseMediaType;\n        this.chunkedResponseBody = chunkedResponseBody;\n        this.releasable = releasable;\n        assert (content == null) != (chunkedResponseBody == null);\n    }\n\n    public RestResponse(RestChannel channel, Exception e) throws IOException {\n        this(channel, ExceptionsHelper.status(e), e);\n    }\n\n    public RestResponse(RestChannel channel, RestStatus status, Exception e) throws IOException {\n        this.status = status;\n        ToXContent.Params params = channel.request();\n        if (e != null) {\n            Supplier<?> messageSupplier = () -> String.format(\n                Locale.ROOT,\n                \"path: %s, params: %s, status: %d\",\n                channel.request().rawPath(),\n                channel.request().params(),\n                status.getStatus()\n            );\n            if (status.getStatus() < 500 || ExceptionsHelper.isNodeOrShardUnavailableTypeException(e)) {\n                SUPPRESSED_ERROR_LOGGER.debug(messageSupplier, e);\n            } else {\n                SUPPRESSED_ERROR_LOGGER.warn(messageSupplier, e);\n            }\n        }\n        // if \"error_trace\" is turned on in the request, we want to render it in the rest response\n        // for that the REST_EXCEPTION_SKIP_STACK_TRACE flag that if \"true\" omits the stack traces is\n        // switched in the xcontent rendering parameters.\n        // For authorization problems (RestStatus.UNAUTHORIZED) we don't want to do this since this could\n        // leak information to the caller who is unauthorized to make this call\n        if (params.paramAsBoolean(\"error_trace\", ERROR_TRACE_DEFAULT) && status != RestStatus.UNAUTHORIZED) {\n            params = new ToXContent.DelegatingMapParams(singletonMap(REST_EXCEPTION_SKIP_STACK_TRACE, \"false\"), params);\n        }\n\n        if (channel.request().getRestApiVersion() == RestApiVersion.V_8 && channel.detailedErrorsEnabled() == false) {\n            deprecationLogger.warn(\n                DeprecationCategory.API,\n                \"http_detailed_errors\",\n                \"The JSON format of non-detailed errors has changed in Elasticsearch 9.0 to match the JSON structure\"\n                    + \" used for detailed errors.\"\n            );\n        }\n\n        try (XContentBuilder builder = channel.newErrorBuilder()) {\n            build(builder, params, status, channel.detailedErrorsEnabled(), e);\n            this.content = BytesReference.bytes(builder);\n            this.responseMediaType = builder.getResponseContentTypeString();\n        }\n        if (e instanceof ElasticsearchException) {\n            copyHeaders(((ElasticsearchException) e));\n        }\n        this.chunkedResponseBody = null;\n        this.releasable = null;\n    }\n\n    public String contentType() {\n        return this.responseMediaType;\n    }\n\n    @Nullable\n    public BytesReference content() {\n        return this.content;\n    }\n\n    @Nullable\n    public ChunkedRestResponseBodyPart chunkedContent() {\n        return chunkedResponseBody;\n    }\n\n    public boolean isChunked() {\n        return chunkedResponseBody != null;\n    }\n\n    public RestStatus status() {\n        return this.status;\n    }\n\n    private static void build(\n        XContentBuilder builder,\n        ToXContent.Params params,\n        RestStatus status,\n        boolean detailedErrorsEnabled,\n        Exception e\n    ) throws IOException {\n        builder.startObject();\n        ElasticsearchException.generateFailureXContent(builder, params, e, detailedErrorsEnabled);\n        builder.field(STATUS, status.getStatus());\n        builder.endObject();\n    }\n\n    static RestResponse createSimpleErrorResponse(RestChannel channel, RestStatus status, String errorMessage) throws IOException {\n        return new RestResponse(\n            status,\n            channel.newErrorBuilder().startObject().field(\"error\", errorMessage).field(\"status\", status.getStatus()).endObject()\n        );\n    }\n\n    public void copyHeaders(ElasticsearchException ex) {\n        Set<String> bodyHeaderKeySet = ex.getBodyHeaderKeys();\n        Set<String> httpHeaderKeySet = ex.getHttpHeaderKeys();\n        if (customHeaders == null) {\n            customHeaders = Maps.newMapWithExpectedSize(bodyHeaderKeySet.size() + httpHeaderKeySet.size());\n        }\n        for (String key : bodyHeaderKeySet) {\n            customHeaders.computeIfAbsent(key, k -> new ArrayList<>()).addAll(ex.getBodyHeader(key));\n        }\n        for (String key : httpHeaderKeySet) {\n            customHeaders.computeIfAbsent(key, k -> new ArrayList<>()).addAll(ex.getHttpHeader(key));\n        }\n    }\n\n    /**\n     * Add a custom header.\n     */\n    public void addHeader(String name, String value) {\n        if (customHeaders == null) {\n            customHeaders = Maps.newMapWithExpectedSize(2);\n        }\n        customHeaders.computeIfAbsent(name, k -> new ArrayList<>()).add(value);\n    }\n\n    /**\n     * Returns custom headers that have been added. This method should not be used to mutate headers.\n     */\n    public Map<String, List<String>> getHeaders() {\n        return Objects.requireNonNullElse(customHeaders, Map.of());\n    }\n\n    public Map<String, List<String>> filterHeaders(Map<String, List<String>> headers) {\n        if (status() == RestStatus.UNAUTHORIZED || status() == RestStatus.FORBIDDEN) {\n            if (headers.containsKey(\"Warning\")) {\n                headers = Maps.copyMapWithRemovedEntry(headers, \"Warning\");\n            }\n            if (headers.containsKey(ELASTIC_PRODUCT_HTTP_HEADER)) {\n                headers = Maps.copyMapWithRemovedEntry(headers, ELASTIC_PRODUCT_HTTP_HEADER);\n            }\n        }\n        return headers;\n    }\n\n    @Override\n    public void close() {\n        Releasables.closeExpectNoException(releasable);\n    }\n}\n",
    "file_path": "./codebase_small/server/src/main/java/org/elasticsearch/rest/RestResponse.java"
  }
]